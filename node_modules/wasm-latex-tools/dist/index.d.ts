interface WebPerlConfig {
    webperlBasePath?: string;
    perlScriptsPath?: string;
    verbose?: boolean;
}
interface ScriptRunOptions {
    input: string;
    args?: string[];
    workingDir?: string;
}
interface ScriptResult {
    success: boolean;
    output: string;
    error?: string;
    exitCode?: number;
}
interface PerlScript {
    name: string;
    path: string;
    dependencies: string[];
}
declare enum ToolType {
    LATEXINDENT = "latexindent",
    TEXCOUNT = "texcount",
    TEXFMT = "texfmt",
    LATEXPAND = "latexpand"
}
interface TexFmtOptions extends ScriptRunOptions {
    wrap?: boolean;
    wraplen?: number;
    tabsize?: number;
    usetabs?: boolean;
}
interface TexCountOptions extends ScriptRunOptions {
    brief?: boolean;
    total?: boolean;
    sum?: boolean;
    verbose?: number;
    includeFiles?: boolean;
    merge?: boolean;
    additionalFiles?: {
        path: string;
        content: string;
    }[];
}
interface LatexDiffOptions extends ScriptRunOptions {
    oldContent: string;
    type?: 'UNDERLINE' | 'CTRADITIONAL' | 'TRADITIONAL' | 'CFONT' | 'FONTSTRIKE' | 'CCHANGEBAR' | 'CFONTCHBAR' | 'CULINECHBAR' | 'CHANGEBAR' | 'INVISIBLE' | 'BOLD' | 'PDFCOMMENT';
    subtype?: string;
    floattype?: 'FLOATSAFE' | 'IDENTICAL';
    encoding?: string;
    excludeSafecmd?: string;
    appendSafecmd?: string;
    excludeTextcmd?: string;
    appendTextcmd?: string;
    mathMarkup?: number;
    allowSpaces?: boolean;
    flatten?: boolean;
}
interface LatexpandOptions extends ScriptRunOptions {
    keepComments?: boolean;
    keepIncludes?: boolean;
    emptyComments?: boolean;
    defines?: Record<string, string>;
    explain?: boolean;
    showGraphics?: boolean;
    graphicsExtensions?: string;
    expandUsepackage?: boolean;
    expandBbl?: string;
    biber?: string;
    fatal?: boolean;
    makeatletter?: boolean;
    additionalFiles?: {
        path: string;
        content: string;
    }[];
}
interface EmscriptenFS {
    writeFile(path: string, data: string | Uint8Array, options?: {
        encoding?: string;
    }): void;
    readFile(path: string, options?: {
        encoding?: string;
    }): string | Uint8Array;
    mkdir(path: string, mode?: number): void;
    unlink(path: string): void;
    stat(path: string): any;
}
interface PerlInstance {
    init(callback: () => void): void;
    start(args: string[]): void;
    eval(code: string): any;
    exitStatus: number;
    output: (str: string, chan: number) => void;
}
declare global {
    interface Window {
        Perl: PerlInstance;
        Module: any;
        FS: EmscriptenFS;
    }
}

declare class WebPerlRunner {
    private config;
    private logger;
    private initialized;
    private initializing;
    private perlRunnerIframe;
    private perlRunner;
    constructor(config?: WebPerlConfig);
    initialize(): Promise<void>;
    private loadPerlRunner;
    private waitForInitialization;
    runScript(argv: string[], inputs?: {
        fn: string;
        text: string;
    }[], outputs?: string[], workingDir?: string): Promise<ScriptResult>;
    private sortInputsByDepth;
    isInitialized(): boolean;
    getConfig(): Required<WebPerlConfig>;
}

declare class FileSystemManager {
    private logger;
    private fs;
    constructor(verbose?: boolean);
    initialize(): void;
    writeFile(path: string, content: string): void;
    readFile(path: string): string;
    fileExists(path: string): boolean;
    private ensureDirectory;
    deleteFile(path: string): void;
}

declare class ScriptLoader {
    private fsManager;
    private logger;
    private loadedScripts;
    constructor(fsManager: FileSystemManager, verbose?: boolean);
    loadScript(script: PerlScript, basePath: string): Promise<void>;
    private loadDependencies;
    private loadMainScript;
    private loadFile;
    isLoaded(scriptName: string): boolean;
}

declare class Logger {
    private verbose;
    constructor(verbose?: boolean);
    debug(message: string, ...args: any[]): void;
    info(message: string, ...args: any[]): void;
    warn(message: string, ...args: any[]): void;
    error(message: string, ...args: any[]): void;
}

type VfsInput = {
    fn: string;
    text: string;
};
declare abstract class BaseTool {
    protected runner: WebPerlRunner;
    protected logger: Logger;
    private filesLoaded;
    preloadedFiles: VfsInput[];
    constructor(runner: WebPerlRunner, verbose?: boolean);
    abstract getScriptPath(): string;
    abstract getDependencyPaths(): string[];
    protected ensureLoaded(): Promise<void>;
    private fetchAllFiles;
    protected executeLatexDiff(options: LatexDiffOptions): Promise<ScriptResult>;
    protected executeScript(options: ScriptRunOptions): Promise<ScriptResult>;
    protected abstract buildArguments(inputPath: string, newPath: string, outputPath: string, options: ScriptRunOptions): string[];
}

declare class TexCount extends BaseTool {
    getScriptPath(): string;
    getDependencyPaths(): string[];
    count(options: TexCountOptions): Promise<ScriptResult>;
    private executeScriptWithWorkDir;
    protected buildArguments(inputPath: string, newPath: "", outputPath: string, options: ScriptRunOptions): string[];
    parseOutput(output: string): TexCountResult;
}
interface TexCountResult {
    words: number;
    headers: number;
    captions: number;
    raw: string;
}

declare class LatexDiff extends BaseTool {
    getScriptPath(): string;
    getDependencyPaths(): string[];
    diff(oldContent: string, newContent: string, options?: LatexDiffOptions): Promise<ScriptResult>;
    protected executeLatexDiff(options: LatexDiffOptions): Promise<ScriptResult>;
    protected buildArguments(oldPath: string, newPath: string, outputPath: string, options: ScriptRunOptions): string[];
}

declare class TexFmt {
    private logger;
    private wasmInitialized;
    private wasmModule;
    private wasmBasePath;
    constructor(verbose?: boolean, wasmBasePath?: string);
    private ensureWasmLoaded;
    private buildConfig;
    format(options: TexFmtOptions): Promise<ScriptResult>;
}

declare class Latexpand extends BaseTool {
    getScriptPath(): string;
    getDependencyPaths(): string[];
    expand(options: LatexpandOptions): Promise<ScriptResult>;
    private executeScriptWithWorkDir;
    protected buildArguments(inputPath: string, newPath: string, outputPath: string, options: ScriptRunOptions): string[];
}

export { FileSystemManager, LatexDiff, Latexpand, Logger, ScriptLoader, TexCount, TexFmt, ToolType, WebPerlRunner };
export type { LatexDiffOptions, LatexpandOptions, ScriptResult, ScriptRunOptions, TexCountOptions, TexCountResult, TexFmtOptions, WebPerlConfig };
