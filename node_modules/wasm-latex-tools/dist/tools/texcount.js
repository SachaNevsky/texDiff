import { BaseTool } from './base-tool';
export class TexCount extends BaseTool {
    getScriptPath() {
        return '/texcount.pl';
    }
    getDependencyPaths() {
        return [];
    }
    async count(options) {
        return this.executeScriptWithWorkDir(options);
    }
    async executeScriptWithWorkDir(options) {
        await this.ensureLoaded();
        const t = Date.now();
        const workDir = `/tmp/work_${t}`;
        const inputPath = `${workDir}/main.tex`;
        const outputPath = `/tmp/output_${t}.tex`;
        const args = this.buildArguments('main.tex', "", outputPath, options);
        const inputs = [
            ...this.preloadedFiles,
            { fn: inputPath, text: options.input },
        ];
        if (options.additionalFiles) {
            for (const file of options.additionalFiles) {
                const fullPath = `${workDir}/${file.path}`;
                inputs.push({ fn: fullPath, text: file.content });
            }
        }
        const outputs = [outputPath];
        return this.runner.runScript(args, inputs, outputs, workDir);
    }
    buildArguments(inputPath, newPath, outputPath, options) {
        const texOptions = options;
        const scriptPath = this.getScriptPath();
        const args = [scriptPath];
        if (texOptions.brief)
            args.push('-brief');
        if (texOptions.total)
            args.push('-total');
        if (texOptions.sum)
            args.push('-sum');
        if (texOptions.verbose !== undefined)
            args.push(`-v${texOptions.verbose}`);
        if (texOptions.includeFiles)
            args.push('-inc');
        if (texOptions.merge)
            args.push('-merge');
        if (texOptions.args)
            args.push(...texOptions.args);
        args.push(inputPath);
        return args;
    }
    parseOutput(output) {
        const lines = output.trim().split('\n');
        const result = {
            words: 0,
            headers: 0,
            captions: 0,
            raw: output
        };
        for (const line of lines) {
            if (line.includes('Words in text:')) {
                result.words = parseInt(line.split(':')[1].trim(), 10) || 0;
            }
            else if (line.includes('Words in headers:')) {
                result.headers = parseInt(line.split(':')[1].trim(), 10) || 0;
            }
            else if (line.includes('Words outside text')) {
                result.captions = parseInt(line.split(':')[1].trim(), 10) || 0;
            }
        }
        return result;
    }
}
//# sourceMappingURL=texcount.js.map