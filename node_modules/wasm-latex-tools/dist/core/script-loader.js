import { Logger } from '../utils/logger';
export class ScriptLoader {
    constructor(fsManager, verbose = false) {
        this.loadedScripts = new Set();
        this.fsManager = fsManager;
        this.logger = new Logger(verbose);
    }
    async loadScript(script, basePath) {
        if (this.loadedScripts.has(script.name)) {
            this.logger.debug(`Script already loaded: ${script.name}`);
            return;
        }
        this.logger.info(`Loading script: ${script.name}`);
        try {
            await this.loadDependencies(script, basePath);
            await this.loadMainScript(script, basePath);
            this.loadedScripts.add(script.name);
            this.logger.info(`Script loaded successfully: ${script.name}`);
        }
        catch (error) {
            throw new Error(`Failed to load script ${script.name}: ${error}`);
        }
    }
    async loadDependencies(script, basePath) {
        for (const dep of script.dependencies) {
            await this.loadFile(dep, basePath);
        }
    }
    async loadMainScript(script, basePath) {
        await this.loadFile(script.path, basePath);
    }
    async loadFile(path, basePath) {
        const fullUrl = `${basePath}${path}`;
        const virtualPath = `/perl${path}`;
        try {
            const response = await fetch(fullUrl);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            const content = await response.text();
            this.fsManager.writeFile(virtualPath, content);
            this.logger.debug(`Loaded file: ${virtualPath}`);
        }
        catch (error) {
            throw new Error(`Failed to fetch ${fullUrl}: ${error}`);
        }
    }
    isLoaded(scriptName) {
        return this.loadedScripts.has(scriptName);
    }
}
//# sourceMappingURL=script-loader.js.map