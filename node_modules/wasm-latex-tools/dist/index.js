class Logger {
    constructor(verbose = false) {
        this.verbose = verbose;
    }
    debug(message, ...args) {
        if (this.verbose) {
            console.debug(`[WebPerl Debug] ${message}`, ...args);
        }
    }
    info(message, ...args) {
        console.info(`[WebPerl] ${message}`, ...args);
    }
    warn(message, ...args) {
        console.warn(`[WebPerl Warning] ${message}`, ...args);
    }
    error(message, ...args) {
        console.error(`[WebPerl Error] ${message}`, ...args);
    }
}

class ErrorHandler {
    static handle(error, context) {
        const message = this.getMessage(error);
        const fullMessage = context ? `${context}: ${message}` : message;
        return new Error(fullMessage);
    }
    static getMessage(error) {
        if (error instanceof Error) {
            return error.message;
        }
        return String(error);
    }
}

class WebPerlRunner {
    constructor(config = {}) {
        this.initialized = false;
        this.initializing = false;
        this.perlRunnerIframe = null;
        this.perlRunner = null;
        this.config = {
            webperlBasePath: config.webperlBasePath || '/core/webperl',
            perlScriptsPath: config.perlScriptsPath || '/core/perl',
            verbose: config.verbose ?? false
        };
        this.logger = new Logger(this.config.verbose);
    }
    async initialize() {
        if (this.initialized)
            return;
        if (this.initializing) {
            await this.waitForInitialization();
            return;
        }
        this.initializing = true;
        this.logger.info('Initializing WebPerl...');
        try {
            await this.loadPerlRunner();
            this.initialized = true;
            this.logger.info('WebPerl initialized successfully');
        }
        catch (error) {
            this.initializing = false;
            throw ErrorHandler.handle(error, 'Failed to initialize WebPerl');
        }
        finally {
            this.initializing = false;
        }
    }
    async loadPerlRunner() {
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                reject(new Error('Timeout waiting for Perl runner to initialize'));
            }, 30000);
            const messageHandler = (event) => {
                const data = event.data;
                if (data.perlRunnerState === 'Ready') {
                    clearTimeout(timeout);
                    window.removeEventListener('message', messageHandler);
                    this.perlRunner = event.source;
                    this.logger.debug('Perl runner is ready');
                    resolve();
                }
            };
            window.addEventListener('message', messageHandler);
            this.perlRunnerIframe = document.createElement('iframe');
            this.perlRunnerIframe.name = 'perlrunner';
            this.perlRunnerIframe.src = `${this.config.webperlBasePath}/perlrunner.html`;
            this.perlRunnerIframe.style.display = 'none';
            this.perlRunnerIframe.onerror = () => {
                clearTimeout(timeout);
                window.removeEventListener('message', messageHandler);
                reject(new Error(`Failed to load ${this.config.webperlBasePath}/perlrunner.html`));
            };
            document.body.appendChild(this.perlRunnerIframe);
            const pollForRunner = setInterval(() => {
                const runnerFrame = this.perlRunnerIframe?.contentWindow;
                if (runnerFrame) {
                    runnerFrame.postMessage({ perlRunnerDiscovery: 1 }, '*');
                }
            }, 100);
            setTimeout(() => clearInterval(pollForRunner), 30000);
        });
    }
    async waitForInitialization() {
        while (this.initializing) {
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        if (!this.initialized) {
            throw new Error('WebPerl initialization failed');
        }
    }
    async runScript(argv, inputs, outputs, workingDir) {
        if (!this.initialized || !this.perlRunner) {
            throw new Error('WebPerl not initialized. Call initialize() first.');
        }
        const sortedInputs = this.sortInputsByDepth(inputs || []);
        return new Promise((resolve, reject) => {
            let stdout = '';
            let stderr = '';
            let exitStatus = 0;
            const outputFiles = [];
            const messageHandler = (event) => {
                const data = event.data;
                if (data.perlOutput) {
                    if (data.perlOutput.chan === 1) {
                        stdout += data.perlOutput.data;
                    }
                    else if (data.perlOutput.chan === 2) {
                        stderr += data.perlOutput.data;
                    }
                }
                else if (data.perlOutputFiles) {
                    outputFiles.push(...data.perlOutputFiles);
                }
                else if (data.perlRunnerState === 'Ended') {
                    window.removeEventListener('message', messageHandler);
                    if ('exitStatus' in data) {
                        exitStatus = data.exitStatus;
                    }
                    if (outputFiles.length > 0) {
                        stdout = outputFiles[0].text;
                    }
                    resolve({
                        success: exitStatus === 0,
                        output: stdout,
                        error: stderr || undefined,
                        exitCode: exitStatus
                    });
                }
                else if (data.perlRunnerError) {
                    window.removeEventListener('message', messageHandler);
                    reject(new Error(data.perlRunnerError));
                }
            };
            window.addEventListener('message', messageHandler);
            const runData = { argv };
            if (sortedInputs.length > 0)
                runData.inputs = sortedInputs;
            if (outputs)
                runData.outputs = outputs;
            if (workingDir)
                runData.cwd = workingDir;
            if (!this.perlRunner) {
                window.removeEventListener('message', messageHandler);
                reject(new Error('Perl runner not available'));
                return;
            }
            this.perlRunner.postMessage({ runPerl: runData }, '*');
            setTimeout(() => {
                window.removeEventListener('message', messageHandler);
                reject(new Error('Timeout waiting for script execution'));
            }, 60000);
        });
    }
    sortInputsByDepth(inputs) {
        return inputs.slice().sort((a, b) => {
            const depthA = a.fn.split('/').length;
            const depthB = b.fn.split('/').length;
            return depthA - depthB;
        });
    }
    isInitialized() {
        return this.initialized;
    }
    getConfig() {
        return { ...this.config };
    }
}

class FileSystemManager {
    constructor(verbose = false) {
        this.logger = new Logger(verbose);
    }
    initialize() {
        if (!window.FS) {
            throw new Error('Emscripten FS not available');
        }
        this.fs = window.FS;
        this.logger.debug('FileSystem initialized');
    }
    writeFile(path, content) {
        try {
            this.ensureDirectory(path);
            this.fs.writeFile(path, content, { encoding: 'utf8' });
            this.logger.debug(`File written: ${path}`);
        }
        catch (error) {
            throw new Error(`Failed to write file ${path}: ${error}`);
        }
    }
    readFile(path) {
        try {
            const result = this.fs.readFile(path, { encoding: 'utf8' });
            return typeof result === 'string' ? result : new TextDecoder().decode(result);
        }
        catch (error) {
            throw new Error(`Failed to read file ${path}: ${error}`);
        }
    }
    fileExists(path) {
        try {
            this.fs.stat(path);
            return true;
        }
        catch {
            return false;
        }
    }
    ensureDirectory(filePath) {
        const dir = filePath.substring(0, filePath.lastIndexOf('/'));
        if (!dir)
            return;
        const parts = dir.split('/').filter(p => p);
        let currentPath = '';
        for (const part of parts) {
            currentPath += '/' + part;
            try {
                this.fs.mkdir(currentPath);
            }
            catch (error) {
                if (error.code && error.code !== 'EEXIST') {
                    throw error;
                }
            }
        }
    }
    deleteFile(path) {
        try {
            if (this.fileExists(path)) {
                this.fs.unlink(path);
                this.logger.debug(`File deleted: ${path}`);
            }
        }
        catch (error) {
            throw new Error(`Failed to delete file ${path}: ${error}`);
        }
    }
}

class ScriptLoader {
    constructor(fsManager, verbose = false) {
        this.loadedScripts = new Set();
        this.fsManager = fsManager;
        this.logger = new Logger(verbose);
    }
    async loadScript(script, basePath) {
        if (this.loadedScripts.has(script.name)) {
            this.logger.debug(`Script already loaded: ${script.name}`);
            return;
        }
        this.logger.info(`Loading script: ${script.name}`);
        try {
            await this.loadDependencies(script, basePath);
            await this.loadMainScript(script, basePath);
            this.loadedScripts.add(script.name);
            this.logger.info(`Script loaded successfully: ${script.name}`);
        }
        catch (error) {
            throw new Error(`Failed to load script ${script.name}: ${error}`);
        }
    }
    async loadDependencies(script, basePath) {
        for (const dep of script.dependencies) {
            await this.loadFile(dep, basePath);
        }
    }
    async loadMainScript(script, basePath) {
        await this.loadFile(script.path, basePath);
    }
    async loadFile(path, basePath) {
        const fullUrl = `${basePath}${path}`;
        const virtualPath = `/perl${path}`;
        try {
            const response = await fetch(fullUrl);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            const content = await response.text();
            this.fsManager.writeFile(virtualPath, content);
            this.logger.debug(`Loaded file: ${virtualPath}`);
        }
        catch (error) {
            throw new Error(`Failed to fetch ${fullUrl}: ${error}`);
        }
    }
    isLoaded(scriptName) {
        return this.loadedScripts.has(scriptName);
    }
}

class BaseTool {
    constructor(runner, verbose = false) {
        this.filesLoaded = false;
        this.preloadedFiles = [];
        this.runner = runner;
        this.logger = new Logger(verbose);
    }
    async ensureLoaded() {
        if (!this.runner.isInitialized()) {
            await this.runner.initialize();
        }
        if (!this.filesLoaded) {
            await this.fetchAllFiles();
            this.filesLoaded = true;
        }
    }
    async fetchAllFiles() {
        const config = this.runner.getConfig();
        const filesToLoad = [
            { path: this.getScriptPath(), virtual: this.getScriptPath() },
            ...this.getDependencyPaths().map(path => ({ path, virtual: path })),
        ];
        const inputs = [];
        for (const file of filesToLoad) {
            const url = `${config.perlScriptsPath}${file.path}`;
            this.logger.debug(`Fetching file from ${url}`);
            try {
                const resp = await fetch(url);
                if (!resp.ok)
                    throw new Error(`HTTP ${resp.status}: ${resp.statusText}`);
                const content = await resp.text();
                inputs.push({ fn: file.virtual, text: content });
                this.logger.debug(`Fetched: ${file.path}`);
            }
            catch (err) {
                throw new Error(`Failed to load file ${file.path}: ${err}`);
            }
        }
        this.preloadedFiles = inputs;
    }
    async executeLatexDiff(options) {
        await this.ensureLoaded();
        const t = Date.now();
        const oldPath = `/tmp/old_${t}.tex`;
        const newPath = `/tmp/new_${t}.tex`;
        const outputPath = `/tmp/diff_${t}.tex`;
        const args = this.buildArguments(oldPath, newPath, outputPath, options);
        const inputs = [
            ...this.preloadedFiles,
            { fn: oldPath, text: options.oldContent },
            { fn: newPath, text: options.input }
        ];
        const outputs = [outputPath];
        return this.runner.runScript(args, inputs, outputs);
    }
    async executeScript(options) {
        await this.ensureLoaded();
        const t = Date.now();
        const inputPath = `/tmp/input_${t}.tex`;
        const outputPath = `/tmp/output_${t}.tex`;
        const args = this.buildArguments(inputPath, "", outputPath, options);
        const inputs = [
            ...this.preloadedFiles,
            { fn: inputPath, text: options.input },
        ];
        const outputs = [outputPath];
        return this.runner.runScript(args, inputs, outputs);
    }
}

class TexCount extends BaseTool {
    getScriptPath() {
        return '/texcount.pl';
    }
    getDependencyPaths() {
        return [];
    }
    async count(options) {
        return this.executeScriptWithWorkDir(options);
    }
    async executeScriptWithWorkDir(options) {
        await this.ensureLoaded();
        const t = Date.now();
        const workDir = `/tmp/work_${t}`;
        const inputPath = `${workDir}/main.tex`;
        const outputPath = `/tmp/output_${t}.tex`;
        const args = this.buildArguments('main.tex', "", outputPath, options);
        const inputs = [
            ...this.preloadedFiles,
            { fn: inputPath, text: options.input },
        ];
        if (options.additionalFiles) {
            for (const file of options.additionalFiles) {
                const fullPath = `${workDir}/${file.path}`;
                inputs.push({ fn: fullPath, text: file.content });
            }
        }
        const outputs = [outputPath];
        return this.runner.runScript(args, inputs, outputs, workDir);
    }
    buildArguments(inputPath, newPath, outputPath, options) {
        const texOptions = options;
        const scriptPath = this.getScriptPath();
        const args = [scriptPath];
        if (texOptions.brief)
            args.push('-brief');
        if (texOptions.total)
            args.push('-total');
        if (texOptions.sum)
            args.push('-sum');
        if (texOptions.verbose !== undefined)
            args.push(`-v${texOptions.verbose}`);
        if (texOptions.includeFiles)
            args.push('-inc');
        if (texOptions.merge)
            args.push('-merge');
        if (texOptions.args)
            args.push(...texOptions.args);
        args.push(inputPath);
        return args;
    }
    parseOutput(output) {
        const lines = output.trim().split('\n');
        const result = {
            words: 0,
            headers: 0,
            captions: 0,
            raw: output
        };
        for (const line of lines) {
            if (line.includes('Words in text:')) {
                result.words = parseInt(line.split(':')[1].trim(), 10) || 0;
            }
            else if (line.includes('Words in headers:')) {
                result.headers = parseInt(line.split(':')[1].trim(), 10) || 0;
            }
            else if (line.includes('Words outside text')) {
                result.captions = parseInt(line.split(':')[1].trim(), 10) || 0;
            }
        }
        return result;
    }
}

class LatexDiff extends BaseTool {
    getScriptPath() {
        return '/latexdiff.pl';
    }
    getDependencyPaths() {
        return [];
    }
    async diff(oldContent, newContent, options) {
        const mergedOptions = {
            input: newContent,
            oldContent,
            ...options
        };
        return this.executeLatexDiff(mergedOptions);
    }
    async executeLatexDiff(options) {
        await this.ensureLoaded();
        const t = Date.now();
        const oldPath = `/tmp/old_${t}.tex`;
        const newPath = `/tmp/new_${t}.tex`;
        const outputPath = `/tmp/diff_${t}.tex`;
        const args = this.buildArguments(oldPath, newPath, outputPath, options);
        const inputs = [
            ...this.preloadedFiles,
            { fn: oldPath, text: options.oldContent },
            { fn: newPath, text: options.input }
        ];
        const outputs = [outputPath];
        return this.runner.runScript(args, inputs, outputs);
    }
    buildArguments(oldPath, newPath, outputPath, options) {
        const diffOptions = options;
        const scriptPath = this.getScriptPath();
        const args = [scriptPath];
        if (diffOptions.type)
            args.push(`--type=${diffOptions.type}`);
        if (diffOptions.subtype)
            args.push(`--subtype=${diffOptions.subtype}`);
        if (diffOptions.floattype)
            args.push(`--floattype=${diffOptions.floattype}`);
        if (diffOptions.encoding)
            args.push(`--encoding=${diffOptions.encoding}`);
        if (diffOptions.excludeSafecmd)
            args.push(`--exclude-safecmd=${diffOptions.excludeSafecmd}`);
        if (diffOptions.appendSafecmd)
            args.push(`--append-safecmd=${diffOptions.appendSafecmd}`);
        if (diffOptions.excludeTextcmd)
            args.push(`--exclude-textcmd=${diffOptions.excludeTextcmd}`);
        if (diffOptions.appendTextcmd)
            args.push(`--append-textcmd=${diffOptions.appendTextcmd}`);
        if (diffOptions.mathMarkup !== undefined)
            args.push(`--math-markup=${diffOptions.mathMarkup}`);
        if (diffOptions.allowSpaces)
            args.push('--allow-spaces');
        if (diffOptions.flatten)
            args.push('--flatten');
        args.push(oldPath, newPath);
        return args;
    }
}

class TexFmt {
    constructor(verbose = false, wasmBasePath = '/core/texfmt') {
        this.wasmInitialized = false;
        this.wasmModule = null;
        this.logger = new Logger(verbose);
        this.wasmBasePath = wasmBasePath;
    }
    async ensureWasmLoaded() {
        if (this.wasmInitialized && this.wasmModule) {
            return;
        }
        try {
            const wasmModule = await import(/* webpackIgnore: true */ `${this.wasmBasePath}/tex_fmt.js`);
            await wasmModule.default();
            this.wasmModule = wasmModule;
            this.wasmInitialized = true;
            this.logger.debug('tex-fmt WASM module initialized');
        }
        catch (error) {
            throw ErrorHandler.handle(error, 'Failed to load tex-fmt WASM module');
        }
    }
    buildConfig(options) {
        const config = ['# tex-fmt.toml'];
        if (options.wrap !== undefined) {
            config.push(`wrap = ${options.wrap}`);
        }
        if (options.wraplen !== undefined) {
            config.push(`wraplen = ${options.wraplen}`);
        }
        if (options.tabsize !== undefined) {
            config.push(`tabsize = ${options.tabsize}`);
        }
        if (options.usetabs !== undefined) {
            config.push(`tabchar = "${options.usetabs ? 'tab' : 'space'}"`);
        }
        config.push('lists = []');
        config.push('no-indent-envs = []');
        return config.join('\n');
    }
    async format(options) {
        await this.ensureWasmLoaded();
        try {
            const config = this.buildConfig(options);
            this.logger.debug(`Running tex-fmt with config:\n${config}`);
            const result = this.wasmModule.main(options.input, config);
            return {
                success: true,
                output: result.output,
                error: result.logs || undefined,
                exitCode: 0
            };
        }
        catch (error) {
            const errorMsg = ErrorHandler.getMessage(error);
            this.logger.error('tex-fmt formatting failed:', errorMsg);
            return {
                success: false,
                output: '',
                error: errorMsg,
                exitCode: 1
            };
        }
    }
}

class Latexpand extends BaseTool {
    getScriptPath() {
        return '/latexpand.pl';
    }
    getDependencyPaths() {
        return [];
    }
    async expand(options) {
        return this.executeScriptWithWorkDir(options);
    }
    async executeScriptWithWorkDir(options) {
        await this.ensureLoaded();
        const t = Date.now();
        const workDir = `/tmp/work_${t}`;
        const inputPath = `${workDir}/main.tex`;
        const args = this.buildArguments('main.tex', "", '', options);
        const inputs = [
            ...this.preloadedFiles,
            { fn: inputPath, text: options.input },
        ];
        if (options.additionalFiles) {
            for (const file of options.additionalFiles) {
                const fullPath = `${workDir}/${file.path}`;
                inputs.push({ fn: fullPath, text: file.content });
            }
        }
        const result = await this.runner.runScript(args, inputs, undefined, workDir);
        if (result.success && result.output && result.output.trim()) {
            return result;
        }
        if (result.success && (!result.output || !result.output.trim())) {
            return {
                success: false,
                output: '',
                error: `Latexpand produced no output. Exit code: ${result.exitCode}\nSTDOUT length: ${result.output?.length || 0}\nSTDERR: ${result.error || 'none'}`,
                exitCode: result.exitCode
            };
        }
        return result;
    }
    buildArguments(inputPath, newPath, outputPath, options) {
        const expandOptions = options;
        const scriptPath = this.getScriptPath();
        const args = [scriptPath];
        if (expandOptions.keepComments)
            args.push('--keep-comments');
        if (expandOptions.keepIncludes)
            args.push('--keep-includes');
        if (expandOptions.emptyComments)
            args.push('--empty-comments');
        if (expandOptions.defines) {
            for (const [key, value] of Object.entries(expandOptions.defines)) {
                args.push('--define', `${key}=${value}`);
            }
        }
        if (expandOptions.explain)
            args.push('--explain');
        if (expandOptions.showGraphics)
            args.push('--show-graphics');
        if (expandOptions.graphicsExtensions) {
            args.push('--graphics-extensions', expandOptions.graphicsExtensions);
        }
        if (expandOptions.expandUsepackage)
            args.push('--expand-usepackage');
        if (expandOptions.expandBbl)
            args.push('--expand-bbl', expandOptions.expandBbl);
        if (expandOptions.biber)
            args.push('--biber', expandOptions.biber);
        if (expandOptions.fatal)
            args.push('--fatal');
        if (expandOptions.makeatletter)
            args.push('--makeatletter');
        if (expandOptions.args)
            args.push(...expandOptions.args);
        args.push(inputPath);
        return args;
    }
}

export { FileSystemManager, LatexDiff, Latexpand, Logger, ScriptLoader, TexCount, TexFmt, WebPerlRunner };
//# sourceMappingURL=index.js.map
