% !TEX encoding = UTF-8 Unicode
% !TEX TS-program = pdflatex

\documentclass[11pt,titlepage,a4paper]{article}\errorcontextlines=100
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{lmodern,textcomp,mflogo}
\usepackage{amsmath,fancyvrb,graphicx,verbatim,afterpage,trace}
\usepackage{etoolbox,enumitem,xspace,xcolor,euclideangeometry}
\usepackage{url}

\providecommand\file{}
\renewcommand*\file[1]{{\normalfont\texttt{#1}}}
\providecommand\prog{}
\renewcommand*\prog[1]{{\normalfont\texttt{#1}}}
\newcommand*\conta[1]{\texttt{\slshape#1}}
\providecommand\cs{}
\renewcommand\cs[1]{{\normalfont\texttt{\char92#1}}}
\providecommand\meta{}
\renewcommand*\meta[1]{{\normalfont$\langle$\textit{#1}$\rangle$}}
\providecommand\marg{}
\renewcommand*\marg[1]{{\ttfamily \char123\meta{#1}\char125}}
\newcommand*\Marg[1]{{\normalfont\ttfamily\{#1\}}}\let\Arg\Marg
\providecommand\oarg{}
\renewcommand*\oarg[1]{{\ttfamily[\meta{#1}]}}
\newcommand*\Oarg[1]{{\ttfamily[#1]}}
\newcommand*\aarg[1]{{\ttfamily{<\meta{#1}>}}}
\newcommand*\Aarg[1]{{\ttfamily<#1>}}
\newcommand*\Bambiente[1]{\texttt{\char92begin\{#1\}}}
\newcommand*\Eambiente[1]{\texttt{\char92end\{#1\}}}
\newcommand*\garg[1]{\texttt{(\splitgarg#1,!)}}\let\parg\garg
\newcommand*\Garg[1]{\texttt{(#1)}}\let\Parg\Garg
  \def\secgarg#1,{#1}
  \def\splitgarg#1,#2!{%
     \ifstrequal{#2}{}{\meta{#1}}{\meta{#1},\meta{\secgarg#2}}}
\providecommand\pack{}
\renewcommand*\pack[1]{{\normalfont\textsf{#1}}}
\providecommand\opt{}
\renewcommand*\opt[1]{{\normalfont\textsl{#1}}}\let\opz\opt
\providecommand\env{}
\renewcommand*\env[1]{{\normalfont\textit{\bfseries#1}}}\let\amb\env

\providecommand*\ped[1]{\ensuremath{_{\mathrm{#1}}}}
\providecommand*\ap[1]{\ensuremath{^{\mathrm{#1}}}}
\providecommand*\unit[1]{\ensuremath{\,\mathrm{#1}}}
\providecommand*\sigla[1]{\textsc{\lowercase{#1}}}
\providecommand*\iu{\ensuremath{\mathrm{i}}}\let\gei\iu
\providecommand*\eu{\ensuremath{\mathop{\mathrm{e}}\nolimits}}

\providecommand\GetFileInfo{}
\makeatletter
\renewcommand*\GetFileInfo[1]{%
  \def\filename{#1}%
  \def\@tempb##1 v.##2 ##3\relax##4\relax{%
    \def\filedate{##1}\def\fileversion{##2}\def\fileinfo{##3}}%
  \edef\@tempa{\csname ver@#1\endcsname}%
  \expandafter\@tempb\@tempa\relax? ? \relax\relax}
\makeatother

\DeclareRobustCommand*{\Ars}{% for the bibliography
  \textsf{\lower -.48ex\hbox{\rotatebox{-20}{A}}\kern -.3em{rs}}%
  \kern -.05em\TeX\unskip\kern -.17em\lower -.357ex\hbox{nica}\xspace}
  

\definecolor{verdeguit}{rgb}{0, 0.40, 0}
\providecommand\GuIT{\mbox{\color{verdeguit}\def\I{\textcolor{black}{I}}%
  \fontfamily{lmr}\fontseries{m}\fontshape{sc}\selectfont
g\raisebox{-0.715ex}{\kern-0.26em u}\kern-0.13em\I\kern-0.14em t}\xspace}


\makeatletter
\AfterEndPreamble{%
\DeclareRobustCommand{\TeX}{T\kern-.1667em\lower.5ex\hbox{E}\kern-.125emX\@\xspace}
\DeclareRobustCommand{\LaTeX}{L\kern-.36em%
        {\sbox\z@ T%
         \vbox to\ht\z@{\hbox{\check@mathfonts
                              \fontsize\sf@size\z@
                              \math@fontsfalse\selectfont
                              A}%
                        \vss}%
        }%
        \kern-.15em%
        \TeX}}\makeatother

\DeclareRobustCommand*\TeXLive{\TeX\ Live\xspace}
\DeclareRobustCommand*\MiKTeX{MiK\TeX}
\DeclareRobustCommand*\MacTeX{Mac\TeX}
\DeclareRobustCommand*\pdfLaTeX{pdf\/\LaTeX}
\DeclareRobustCommand*\LuaLaTeX{Lua\LaTeX}
\DeclareRobustCommand*\XeLaTeX{X\ifdim\fontdimen1\font=0pt\kern-0.15em\fi
\lower.5ex\hbox{\rotatebox[origin=c]{180}{E}}%
\ifdim\fontdimen1\font=0pt\kern-0.15em\else\kern-0.275em\fi
\LaTeX}
\DeclareRobustCommand*\TikZ{Ti\emph{k}Z\xspace}
\DeclareRobustCommand*\TUGboat{\textsl{TUG\-boat}\xspace}

\def\hz{\hskip0pt}

\makeatletter
\newwrite\example@out
\newlength\Wboxu \newlength\Wboxd

% Attention!
%
% This is the latest version of the Esempio/Example environment
% It differs from the previous versions because it accepts an optional
% first argument asterisk; if the asterisk is not specified, the
% environment produces the code and the typeset result side by side.
% If the asterisk is specified, the code is typeset first, and its typeset
% result is shown below the code.
% Very handy when the typeset result cannot be shrunk too much and/or
% when the code is really lengthy possibly with lines that are quite long.
% With reasonably short codes and lines that can be folded, the code font
% size can be specified even with a fractional size; obviously, the
% default value is \normalsize, but, if necessary, it can be specified with
% something such as [\setfontsize{8,25}] (if the unit of measure is not
% specified, pt is assumed; otherwise it is possible to specify something
% such as 2.33mm).
% When the asterisk is NOT specified, the \textwidth fraction for the
% code may be specified: default is (0.40); the remaining fraction minus
% \columnsep is used for the code typeset result.
%
\newwrite\example@out
\DeclareDocumentEnvironment{Esempio}{s O{\normalsize} D(){0.40}}
{\par\addvspace{3.0ex plus 0.8ex minus 0.5ex}\vskip -\parskip
\Wboxu=#3\textwidth\relax
\Wboxd=\dimexpr\linewidth-\columnsep-\Wboxu\relax
\begingroup
\@bsphack
\immediate\openout\example@out\jobname-temp.tex
\let\do\@makeother\dospecials\catcode`\^^M\active
\def\verbatim@processline{%
  \immediate\write\example@out{\the\verbatim@line}}%
\verbatim@start\relax}%
{\immediate\closeout\example@out\@esphack\endgroup
\begin{minipage}{\textwidth}%
\IfBooleanTF{#1}{\begin{minipage}{\textwidth}}{\begin{minipage}{\Wboxu}}%
#2\relax
\verbatiminput{\jobname-temp.tex}
\end{minipage}%
\IfBooleanTF{#1}{\par\bigskip}{\hfill}%
\IfBooleanTF{#1}{\begin{minipage}{\textwidth}}{\begin{minipage}{\Wboxd}}%
\raggedleft
\input{\jobname-temp}
\end{minipage}
\end{minipage}\par
}

\makeatother

\newenvironment{ttsintassi}{\begin{lrbox}{0}
\minipage{\dimexpr\linewidth-2\fboxrule-2\fboxsep}\ttfamily\obeylines}%
{\endminipage\end{lrbox}\center\fbox{\box0}\endcenter}
\let\ttsyntax\ttsintassi \let\endttsyntax\endttsintassi

\newcommand\heart[3]{%
\edef\X{\fpeval{#1*16*(sind(#2)^3)}}
\edef\Y{\fpeval{#1*(13*cosd(#2) - 5*cosd(2*#2) 
  - 2*cosd(3*#2) -cosd(4*#2)+2.4)}}
\CopyVect\X,\Y to#3}
\let\cuore\heart

\begin{document}

\begin{titlepage}
\thispagestyle{empty}
\centering
\textsc{\large Claudio Beccari}\\[2ex]
\texttt{claudio dot beccari at gmail dot com}

\vspace{\stretch{2}}

{\LARGE\scshape The \pack{euclideangeometry} package\\
{\large user manual}\par}

\vspace{\baselineskip}


\GetFileInfo{euclideangeometry.sty}
Version \fileversion\ of \filedate

\vspace*{\stretch{5}}
\end{titlepage}

 \begin{abstract}
 This file further extends the functionalities of the \pack{curve2e} 
 package, which, on turn, is an extension of the \pack{pict2e} package
 to the standard \env{picture} environment as defined in the \LaTeX\ 
 kernel source file.

 The \pack{curve2e} package was upgraded a the beginning of 2020; the 
 material of this new package, might have been included in the former one, 
 but it is so specific, that we preferred defining a standalone one; this 
 package takes care of requesting the packages it depends from.

 The purpose is to provide the tools to draw most of the geometrical
 constructions that a high school instructor or bachelor degree professor
 might need in order to teach geometry. The connection to Euclide depends 
 on the fact that in its times calculations were made with ruler, compass, 
 and, apparently, also with ellipsograph.

 The user of this package has available all the machinery provided by
 the \pack{pict2e} and \pack{curve2e} packages, in order to define new 
 functionalities and build macros that draw the necessary lines, circles, 
 and other such objects, as they would have done in the ancient times. 
 Actually just one macro is programmed to solve a linear system of equations
 \end{abstract}
 
 \tableofcontents


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \section*{Warning}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The \pack{euclideangeometry} package requires the advanced functionalities of the \LaTeX\!3 (L3) language; if such functionalities are not available for any reason (incomplete/basic installation of the \TeX system; legacy installation of the \TeX system; the \TeX system has not been updated; \dots) input of this package is stopped, the whole job is aborted, and a visible message is issued. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \section{Introduction}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 The \pack{picture} environment has been available since the very beginning
 of \LaTeX in 1985. At that time it was a very simple environment
 that allowed to draw very simple line graphics with many limitations.
 When \LaTeX was upgraded from \LaTeX\!2.09 to \LaTeXe in 1994, Leslie
 Lamport announced an upgrade that eventually became available in 2003
 with package \pack{pict2e}; in 2006 I wrote the \pack{curve2e} package 
 that added many more functionalities; both packages were upgraded during 
 these years; and now line graphics with the \env{picture} environment 
 can perform pretty well. The package \pack{euclideangeometry} adds even 
 more specific functionalities in order to produce geometric drawings as 
 they were possible in the old times, when calculus and analytic geometry 
 were not available.
 
 In these years other drawing programs were made available to the \TeX 
 community; \pack{PSTricks} and \pack{TikZ} are the most known ones, but 
 there are other less known packages, that perform very well; among the 
 latter I would like to mention \pack{xpicture}, that relies on 
 \pack{pict2e} and \pack{curve2e}, but extends the functionalities with a 
 very smart handling of coordinate systems, that allow to draw many line 
 drawings suitable for teaching geometry in high schools and introductory 
 courses in the university bachelor degree programs.
 
 This package \pack{euclideangeomery} apparently follows the same
 path of \pack{xpicture}, but it avoids defining a new user language
 interface; rather it builds new macros by using the same philosophy of
 the recent \pack{curve2e} package.
 
 It is worth mentioning that now \pack{curve2e} accepts coordinates in both 
 cartesian and  polar form; it allows to identify specific points of the 
 drawing with macros, so the same macro can be used over and over again to 
 address the same points. The package can draw lines, vectors, arcs 
 with no arrow tips, or with one arrow tip, or with arrow tips at both ends,
 arcs included. The macros for drawing poly lines, polygons, circles,
 generic curves (by means of Bézier cubic or quadratic splines) are
 already available; such facilities are documented and exemplified
 in the user manual of \pack{curve2e} package. 

 In what follows there will be several figures drawn with this package;
 in the background there is a red grid where the meshes are
 10\,\cs{unitlenth} apart in both directions; they should help to
 understand the position of the various drawings on the picture canvas.
 This grid is useful also to the end user, while s/he is working on a 
 particular drawing, but when the drawing is finished, the user can 
 delete the grid command or comment out that line of code.
 For what regards the commands used to render the images, their codes can
 be found in the documented code file \pack{euclideangeometry.pdf}.
 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \section{Installing \pack{euclideangeometry}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 You are not supposed to manually install package \pack{euclideangeometry}.
 In facts you have to work with a complete and updated/upgraded \TeX 
 installation, otherwise this package won't work; this means that
 you have done your updating after 2020-01-18. And this package is already
 present in any modern updated complete installation of the \TeX system.
 Otherwise the package will load \pack{curve2e} with an old version
 and file date, and this package will abort its own loading, besides
  aborting the whole job.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \section{Loading \pack{euclideangeometry}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 If you want to use the \pack{euclideangeometry} package, we suggest you 
 load it with the following command:
\begin{flushleft}\obeylines
\cs{usepackage}\oarg{options}\Marg{euclideangeomery}
\end{flushleft}
 The package will take care of managing the possible \meta{options}
 and to call \pack{curve2e} with the such specified options; on turn
 \pack{curve2e} calls \pack{pict2e} passing on the \meta{options}; such
 \meta{options} are only those usable by \pack{pict2e} because neither
 \pack{curve2e} nor \pack{euclideangeometry} use any option. If the
 user is invoking \pack{euclideangeometry}, it is certain s/he does
 not want to use the native picture environment, but the modern
 extended one; therefore the only meaningful possible options are
 \opt{latex} and \opt{pstricks}; such options influence only the shape
 of the arrow tips; with option \opt{latex} they are triangular,
 while with \opt{pstricks} they have the shape of a stealth
 aircraft. The difference is very small; therefore we imagine that
 even if these options are available, they might never be used.

 Nothing happens if the user forgets this mechanism; therefore if s/he
 loads \pack{curve2e} and/or \pack{pict2e}, before
 \pack{euclideangeomentry} the only problem that might arise is an
 “Option clash” error message; if two of these packages are selected
 with different arrow tips; not impossible, of course, by we deem
 it very unlikely.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \section{Available commands}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

 The commands available with the first extension \pack{pict2e} to the native
 \amb{picture} environment, maintain their names but do not maintain the
 same restrictions; in particular there are the following improvements.
\begin{enumerate}[noitemsep]
 \item Lines and vectors are drawn as usual by \cs{put}ting in place
 their forms, but their inclinations are not limited to a limited
 number of slope parameters, originally specified with reciprocally
 prime single digit values not exceeding~6 for lines, and~4 for vectors;
 the length of these sloped objects is still their horizontal component;
 now, the slopes may be described with any signed fractional number not
 exceeding $2^{30}-1$ in absolute value; it still is a limited number of
 slopes, but their combinations are practically countless.
%
\item There is no restriction on the minimum length of lines and vectors.
%
\item Circles and dots can be drawn at any size, not at that dozen
 or so of finite sizes that were accepted with the original environment.
%
\item Ovals may be specified the corner curvature; the default
 size of the quarter circles that make up the oval corners may be
 specified; if no specification is given the radius of such corners
 is the maximum that can be fitted in the oval; in practice it is
 half the shortest value between the oval height and width.

\item The quadratic Bézier splines do not require the specification
 of the number of dots that were used by the native environment to
 draw “arbitrary” curves; now they are drawn with continuous curved
 lines.
\end{enumerate}
 Some new commands were added by \pack{pict2e}
\begin{enumerate}[noitemsep]

\item The third degree (cubic) Bézier splines are sort of new; certainly
 now they are traced with continuous lines; if it is desired, it is
 possible to replace the continuous line with a number of dots so as
 to have a (unevenly) dotted curve. It suffices to specify the number 
 of dots the curve should be made with.

\item\cs{arc} and \cs{arc*} draw an arc or a filled circular sector,
 with their centers at the axes origin; therefore  they need to be put
 in place somewhere else by means of the usual \cs{put} command.

\item The new command \cs{Line} traces a segment from one given point
 to another point; it is very convenient to specify the end points
 instead of the slope the line must have to go form the starting
 point to the ending one. The command does not require the \cs{put}
 command to put the segment in place; nevertheless it can be shifted
 somewhere else with \cs{put} if it becomes necessary.

\item The new command \cs{polyline} draws a sequence of connected
 segments that form a piecewise linear “curve”; the way segments are
 joined to one another depend from the “join” specifiers that
 \pack{pict2e} has introduced; they will be described further on.

\item \cs{polygon} and \cs{polygon*} produce closed paths as it would
 be possible when using \cs{polyline} and specifying the last point
 coincident with the first point of that curve. If the asterisk is used 
 the closed path is filled with the default color.
\end{enumerate}

 There were also the low level commands user interfaces to the various 
 drivers; these drivers really exist, but \pack{pict2e}
 knows how to detect the correct language of the necessary drive;
 the user is therefore allowed to pretend to ignore the existence
 of such drivers, and s/he can simply use these low level commands; their 
 names are almost self explanatory.
\begin{enumerate}[noitemsep]
\item \cs{moveto} Sets the start of a line to an initial point.

\item \cs{lineto} traces a segment up to a specified point.

\item \cs{curveto} traces a third degree Bézier spline  up to the third 
 specified point, while using the other two ones as control 
 points.\footnote{If these terms are unfamiliar, please read the \pack{pict2e} documentation.}

 \item \cs{circlearc} traces a circumference arc from the last line
 point to a specified destination; its center, its angle amplitude, its
 initial point are among the specified arguments, but the reader should
 check on the \pack{pict2e} documentation for the details.

\item[]\mbox{\bfseries Attention!} Notice that these commands produce
 just information to trace lines, but by themselves they do not trace 
 anything; in order to actually trace the curve or do other operations 
 with what has been done after the user finished describing the line to be 
 traced, the following low level commands must be used.

\item A \cs{closepath} is necessary if it is desired to
 join the last position to the initial one. But if the last point
 specified coincides with the very first one, a closed loop is
 effectively already completed.

\item If a \cs{strokepath} command is used the line is drawn.

\item If a \cs{fillpath} command is used, the line loop is filled with
 the current color. Notice, if the described line is not a closed loop,
 this filling command acts as if the line first point and last point were
 joined by a straight line.

\end{enumerate}

 While describing a line with the above low level commands, or with
 the previous high level commands, lines and segments join and finish
 as described hereafter; the following commands must be used, possibly
 within a group, before actually tracing a specific line made up with
 several joined lines or curves. Notice that their effect is just
 visible with lines as thin as 1\,pt, and very visible with thicker
 lines.
\begin{enumerate}[noitemsep]
\item \cs{buttcap} truncates each line with a sharp cut perpendicular
 to the line axis exactly through the line end point (default).

\item \cs{roundcap} adds a semicircle to the very end of each line.

\item \cs{squarecap} adds a half square to the very end of each line.

\item \cs{miterjoin} joins two (generally straight) lines with a miter
 (or mitre) joint; this means that the borders of the line are prolonged
 until they meet; it is very nice when the junction angle is not far away
 from, or is larger than $90^\circ$. Apparently for \pack{pict2e} this
 type of joint is the default.

\item \cs{roundjoin} joins each (generally straight) line with
 an arc on the external part of the bend; it is good in most circumstances.

\item \cs{beveljoin} joins two (generally straight) lines with a miter
 joint truncated with a sharp cut perpendicular to the bisector of the
 lines axes; with acute angles it is better than the miter joint, but
 when angles are very small, even this joint is not adequate.
\end{enumerate}

 Notice that \cs{buttcap} is the default, but in general it might be
 better to declare the \cs{roundcap} for the whole document.

 We do not go further in the description of the new \pack{pict2e}
 modified and new new commands; the reader unfamiliar with programmable
 drawing and the \pack{pic2e} extensions can consult that package
 documentation. Actually all commands have been redefined or modified
 by \pack{curve2e} in order to render them at least compatible with
 both the cartesian and polar coordinates. In oder to have a better 
 understanding of these details, see figure~\ref{fig:joins}\footnote{The \cs{polyline} macro has the default join of type bevel; remember to specify a different join type if you want a different one.}.
 
 \begin{figure}[!htb] \centering
 \makebox[\textwidth]{\unitlength=0.009\textwidth
 \begin{picture}(130,50)
 \GraphGrid(130,50)
 \linethickness{4mm}
 \buttcap\miterjoin
 \put(10,10){\polyline[\miterjoin](0,0)(30,0)(30,30)
 \put(0,-10){\makebox(30,10)[b]{\cs{buttcap},\cs{miterjoin}}}}
 \roundcap\roundjoin
 \put(50,10){\polyline[\roundjoin](0,0)(30,0)(30,30)
 \put(0,-10){\makebox(30,10)[b]{\cs{roundcap},\cs{roundjoin}}}}
 \squarecap\beveljoin
 \put(90,10){\polyline(0,0)(30,0)(30,30)
 \put(0,-10){\makebox(30,10)[b]{\cs{squarecap},\cs{beveljoin}}}}
 \end{picture}}
 \caption{Different caps and joins}\label{fig:joins}
 \end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%>>>
\section{\pack{curve2e} extensions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Again we do not enter into the details, because the user can read the
 new user manual \file{curve2e-manual.pdf} simply by entering and
 executing the \verb|texdoc curve2e-manual| command into a terminal or 
 command prompt window; this new manual is available with version~2.2.0 
 (or higher) of \pack{curve2e} and it contains the extensions and sample 
 codes for (simple) sample drawings; some examples are not so simple, but 
 show the power of this package upgrade.

 The most important two changes are $(a)$ the choice of different
 coordinates for addressing points on the drawing canvas, and $(b)$
 the possibility of using macros to identify specific points.
 As already mentioned, such changes have been applied also to most,
 if not all\footnote{I assume I have upgraded all such commands; if not,
 please, send me a bug notice; I will acknowledge your contribution.}
 commands defined by \pack{pict2e}.
 
 \pack{curve2e} defines a lot of operations the user can do with
 the point coordinates; this is done by assuming they are complex
 numbers, or vectors, or roto\-amplification operators, and making
 with such entities a lot of actions compatible with their “incarnation".
 For example multiplying a vector by a roto\`amplification operator,
 in spite the fact that internally they are both represented by ordered
 pairs of (generally) fractional numbers, means simply obtaining a new
 vector rotated and scaled with respect to the original one; the point
 addressed by the first vector, becomes another point in a different
 precise position.

 Below you see several examples of usage of such commands; but here space
 will be saved if a short list is made concerning these “complex number”
 operations.
 
 Remember the double nature of such complex numbers:
\[
z = x + \iu y = m\eu^{\iu \phi}
\]
 therefore addition and subtraction are simply done with
\[
z_1 \pm z_2 = x_1 \pm x_2 +\iu (y_1 \pm y_2)
\]
 Multiplications and divisions are simply done with
\begin{align*}
z_1 z_2 &=( m_1 m_2) \eu^{\iu(\phi_1 + \phi_2)} \\
z_1/z_2 &=( m_1/m_2) \eu^{\iu(\phi_1 - \phi_2)}
\end{align*}
 Squares and square roots\footnote{The square root of a complex number 
 has two complex values; here we do not go into the details on how 
 \pack{curve2e} choses one or the other value. In practice, the 
 \pack{curve2e} macros that use square roots, work mostly on scalars to 
 find magnitudes that are always positive.} are simply done with:
\begin{align*}
z^2      &= m^2\eu^{\iu 2\phi}\\
\sqrt{z} &= \sqrt{m}\eu^{\iu\phi/2}
\end{align*}
 The complex conjugate of a complex number is shown with a superscript
 asterisk:
\[\text{if } z= x+\iu y \text{ then } z^\star = x- \iu y\]
 and from these simple formal rules many results can be obtained;
 and therefore several macros must be defined.

 But let us summarise. Here is a short list with a minimum of
 explanation of the commands functionalities introduced by
 \pack{curve2e}. The user notices that many commands rely on
 a delimited argument command syntax; the first arguments can
 generally be introduced with point macros, as well as numerical
 coordinates (no matter if cartesian and polar ones) while
 the output(s) should always be in form of point macro(s). Parentheses
 for delimiting the ordered pairs or the point macros are seldom
 required. On the other side, the variety of multiple optional
 arguments, sometimes requires the use of different delimiters,
 most often than not the signs~\texttt{<~>}, in addition to the
 usual brackets. These syntax functionalities are available with the
 \pack{xparse} and \pack{xfp} packages, that render the language~L3
 very useful and effective.

 Handling of complex numbers is done with the following commands.
 New commands to draw special objects, are also described.
\begin{enumerate}[noitemsep]
%
\item Cartesian and polar coordinates; they are distinguished by
 their separator; cartesian coordinates are the usual comma separated
 pair \meta{$x,y$}; polar coordinates are specified with a colon
 separated pair \meta{$\theta{:}\,\rho$}. In general they are
 specified within parentheses, but some commands require them without
 any parenthesis. In what follows a generic math symbol, such as for
 example $P_1$, is used to indicate a complex number that addresses
 a particular point, irrespective of the chosen coordinate type,
 or a macro  defined to contain those coordinates.

\item The complex number/vector operations already available with
 \pack{curve2e} are the following; we specify “macro” because in general
 macros are used, instead of explicit numerical values, but for input
 vector macros it is possible to use the comma or colon separated ordered
 pair; “versor” means “unit vector”; angles are always expressed in
 degrees; output quantities are everything follows the key word
 \texttt{to}; output quantities are alway supposed to be in the form
 of control sequences.
\begin{itemize}\small
\item \cs{MakeVectorFrom}\meta{number,number}\meta{numeric macro} to\meta{vector macro}
\item \cs{CopyVect}\meta{vector macro} \texttt{to}\meta{vector macro}
\item \cs{ModOfVect}\meta{vector macro} \texttt{to}\meta{modulus macro}
\item \cs{DirOfVect}\meta{vector macro} \texttt{to}\meta{versor macro}
\item \cs{ModAndDirOfVect}\meta{vector macro} \texttt{to}\meta{modulus macro}
    \texttt{and}\meta{versor macro}
\item \cs{ModAndAngleOfVect}\meta{vector macro} \texttt{to}\meta{modulus macro}
 and\meta{angle macro}
\item \cs{DistanceAndDirOfVect}\meta{1st vector macro}
    \texttt{minus}\meta{2nd vector macro} \texttt{to}\meta{distance macro}
    \texttt{and}\meta{versor macro}
\item \cs{XpartOfVect}\meta{vector macro} \texttt{to}\meta{numerical macro}
\item \cs{YpartOfVect}\meta{vector macro} \texttt{to}\meta{numerical macro}
\item \cs{DirFromAngle}\meta{angle macro} \texttt{to}\meta{versor macro}
\item \cs{ArgOfVect}\meta{vector macro} \texttt{to}\meta{angle macro}
\item \cs{ScaleVect}\meta{vector macro} \texttt{by}\meta{scale factor}
    \texttt{to}\meta{vector macro}
\item \cs{ConjVect}\meta{vector macro} to\meta{conjugate vector macro}
\item \cs{SubVect}\meta{subtrahend vector} \texttt{from}\meta{minuend vector}
    \texttt{to}\meta{vector macro}
\item \cs{AddVect}\meta{1st vector} \texttt{and}\meta{2nd vector}
    \texttt{to}\meta{vector macro}
\item \cs{Multvect}\marg{1st vector}\meta{$\star$}\marg{2nd vector}\meta{$
    \star$}\meta{output vector macro}\newline the asterisks are optional;
    either one changes the \meta{2nd vector} into its complex conjugate
\item \cs{MultVect}\meta{1st vector}\meta{$\star$}\meta{2nd vector}
    \texttt{to}\meta{vector macro}\newline discouraged; maintained for backward
    compatibility; the only optional asterisk changes the \meta{2nd vector}
    into its complex conjugate
\item \cs{Divvect}\marg{dividend vector}\marg{divisor vector}\marg{output
    vector macro}
\item \cs{DivVect}\meta{dividend vector} \texttt{by}\meta{divisor vector}
    \texttt{to}\meta{vector macro}\newline maintained for backwards
    compatibility.
\end{itemize}

\item A new command \cs{segment}\parg{$P_1$}\parg{$P_2$} draws a line that
 joins the specified points.

\item Command \cs{Dashline}\parg{$P_1$}\parg{$P_2$}\marg{dash length}
 draws a dashed line between the specified points; the
 \meta{dash length} is specified as a coefficient of
 \cs{unitlenth} so it is a proportioned  to the diagram scale. The gap
 between dashes is just as wide as the dashes; they are recomputed by
 the command in order to slightly adjust the \meta{dash length} so
 that the line starts at point $P_1$ with a dash, and ends at $P_2$
 again with a dash.

\item Command \cs{Dotline}\parg{$P_1$}\parg{$P_2$}\marg{gap}\oarg{diameter}
 traces a dotted line between the specified points with dots \meta{gap}
 units apart, starting and ending with a dot at the specified points.
 Optionally the absolute diameter of the dots may be specified: a
 diameter of 1\,pt (default) is visible, but it might be too small;
 a diameter of 1\,mm is really very black, and may be too large; if
 the diameter is specified without dimensions they are assumed by
 default to be typographic points.

\item Command \cs{polyline}, \cs{polygon} and \cs{polygon*} are redefined
 to accept both coordinate kinds.

\item Commands \cs{VECTOR}\parg{$P_1$}\parg{$P_2$} (and \cs{VVECTOR}, with the same syntax) draw vectors with one arrow tip at the end, or arrow tips at both ends respectively.

\item New commands \cs{Arc}\parg{center}\parg{start}\marg{angle} and,
 with the same syntax, \cs{VectorArc} and \cs{VectorARC} draw 
 arcs with the specified \meta{center},
 starting at point \meta{start}, with an aperture of \meta{angle}
 degrees (not radians). \cs{Arc} draws the arc without arrow tips;
 \cs{VectorArc} draws the arc with one arrow tip at the end point;
 \cs{VectorARC} draws an arc with arrow tips at both ends.

\item Command \cs{multiput} has been redefined to accept optional
 arguments, besides the use of coordinates of both kinds. The new syntax
 is the following:
\begin{flushleft}\obeylines
\cs{multiput}\oarg{shift}\parg{origin}\parg{step}\marg{number}\marg{object}\oarg{handler}
\end{flushleft}
 where, if you neglect the first and the last (optional) arguments,
 you have the original syntax; the \meta{origin} point is where the first
 \meta{object} is placed; \meta{step} is the displacement of a new
 \meta{object} relative to the previous one; \meta{number} is the
 total number of \meta{object}s put in place by the command; possibly
 the number may be an integer expression computed with the \cs{inteval}
 function of the L3~language, accessed through the \pack{xfp} package
 already loaded by \pack{curve2e}. The new features are \meta{shift},
 that is used to displace the whole drawing somewhere else (in case
 some fine tuning is required), and \meta{handler}; the latter is a
 powerful means to control both the object to be set in place and its
 position; further on there will be examples that show that the object
 can be put not only on straight paths, but also un other curves,
 including parabolas, circles, and other shapes.

\item Another version of repetitive commands \cs{xmultiput} is very
 similar to \cs{multiput} but the iterations are controlled in a
 different way so that it is possible also to draw continuous
 curves describing analytical functions even with parametric
 equations. Further on there will be some examples.

\item The preloaded \pack{xfp} package provides two important 
 functionalities, i.e. two L3 “functions”, \cs{fpeval} and \cs{inteval};
 the latter executes expressions on integer numbers containing the usual
 operators \texttt{+, -, *, /}; the division quotient is rounded to the
 nearest (positive or negative) integer. The former operates with real
 fractional numbers and, in addition to the usual arithmetical operators as
 \cs{inteval}, it can use many mathematical functions, from square roots,
 to exponentials, logarithms, trigonometric and hyperbolic direct and
 inverse functions\footnote{The implementation of inverse hyperbolic
 function is on the L3~Team “to do” list.}, plus other ones. Normally
 fractional numbers are operated on decimal strings, with 16 fractional
 places, and 14 integer places but the L3~functions accept also scientific
 notation. The user can specify truncation or rounding to a specified
 number of digits. Such integer and fractional mathematical operations
 are already integrated in most computations performed by \pack{curve2e}.

\item \pack{curve2e} provides two more L3 functions: \cs{fptest} and
 \cs{fpdowhile} with the following syntax:
\begin{flushleft}\obeylines
\cs{fptest}\marg{test}\marg{true}\marg{false}
\cs{fpdowhile}\marg{test}\marg{actions}
\end{flushleft}
 For both macros the \meta{test} is a logical F3~expression; its operands
 are logical constants, logical values, logical numeric comparisons; its
 operators are the typical \texttt{||}, \texttt{\&\&}, and \texttt{!},
 respectively for OR, AND, and NOT. The logical numerical comparisons
 are mathematical constants or expressions connected with relation
 operators, such as \texttt{>, =, <}; such operators may be negated with
 the NOT operator; therefore, for example, \texttt{!>} means “not greater 
 than”, therefore “lower or equal to”. 

\item The above tests are very useful to control both \cs{fptest} and
 \cs{fpdowhile}. The logical \meta{test} result lets \cs{fptest} execute
 only the \meta{true} or the \meta{false} code. Before using \cs{fpdowhile}
 the \meta{test} expression must be initialised to be \texttt{true};
 the \meta{actions} should contain some code to be iteratively executed,
 but they must contain some assignments, typically a change in an
 iteration counter, such that eventually the \meta{test} logical
 expression becomes \texttt{false}. Lacking this assignments, the
 loop continues to infinity, or better, until a fatal error message
 is issued that informs that the program working memory is exhausted.

\item Such new commands are already used to code the \cs{multiput} and
 \cs{xmultiput} commands, but they are available also to the user who can
 operate in a very advanced way; further on, some examples will show
 some advanced drawings.

\item General curves can be drawn by \pack{pic2e} command \cs{curve}
 that is sort of difficult to use, because the user has to specify
 also the control points of the third order Bézier splines. Some other
 new commands are available with \pack{curve2e}, that are supposed
 to be easier to use; they are described in the following items.

\item The new command \cs{Curve} joins a sequence of third order
 splines by simply specifying the node-direction coordinates; i.e. at the
 junction of two consecutive splines, in a certain interpolation node the
 final previous spline tangent has the same direction as that 
 at the second spline first node; if a change of direction is required, an
 optional new direction can be specified. Therefore this triplet of
 information has the following syntax:
\begin{flushleft}
 \parg{node}\aarg{direction}\oarg{new direction}
\end{flushleft}
 Evidently the \meta{new direction} is specified only for the nodes
 that correspond to a cusp. A variation of the command arguments is
 available by optionally specifying the “looseness” of the curve:
\begin{flushleft}
\parg{node}\aarg{direction\texttt{;}start\texttt{,}end}\oarg{\dots}
\end{flushleft}
 where \meta{start} is the spline starting “looseness” and \meta{end}
 is the spline ending one. These (generally different) values
 are an index of how far the control point is from the adjacent node.
 With this functionality the user has a very good control on the curve
 shape and curvature.

\item A similar command \cs{Qurve} works almost the same way, but it
 traces a quadratic Bézier spline; this one is specified only with two
 nodes an a single control point, therefore is less configurable than
 cubic splines; the same final line may require several quadratic splines
 when just a single cubic spline might do the same job. Notice also that
 quadratic splines are just parabolic arcs, therefore without inflection 
 points, while a cubic spline can have one inflexion point. 

\item A further advanced variation is obtained with the new
 \cs{CurveBetween} command that creates a single cubic spline between two
 given points with the following syntax:
\begin{flushleft}\ttfamily
\cs{CurveBetween}\meta{node1} And\meta{node2} WithDirs \meta{dir1}
    And\meta{dir2}
\end{flushleft}

\item A similar variant command is defined with the following syntax:
\begin{flushleft}\ttfamily
 \cs{CbezierBetween}\meta{node1} And\meta{node2} WithDirs\meta{dir1}
    And\meta{dir2}\\ 
\qquad UsingDists\meta{dist1} And\meta{dist2}
\end{flushleft}
 Usage examples are shown in section~\ref{sec:examples}
\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{ Euclidean geometry commands}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

 With the already large power of \pack{curve2e} there was a push towards
 specialised applications; the first of which was, evidently, geometry;
 that kind of geometry that was used in the ancient times when
 mathematicians did not have available the sophisticated means they
 have today; they did not even have a positional numerical notation, that
 arrived in the “western world” we are familiar with, just by
 the XI-XII century; before replacing the roman numbering system, another
 couple of centuries passed by; real numbers with the notation we use
 today with a decimal separator, had to wait till the XVI century (at
 least); many things that naw are taught in elementary school were
 still a sort of magic until the end of XVIII century.

 Even a simple algebraic second degree equation was a problem.
 In facts the Renaissance was the artistic period when the classical
 proportions were brought back to the artists who could not solve the
 simple equation where a segment of unit length is divided in two
 unequal parts $x$  and $1-x$ such that the following proportion exists
 among the various parts and the whole segment:
\[
\frac{x}{1} = \frac{1-x}{x} \Longrightarrow x = \frac{1}{x} - 1
\]
 today we cam solve the problem by manipulating that simple proportion
 to get
\[
 x^2 + x -1 = 0
\]
 and we know that the equation has two solution of opposite signs, and that
 their magnitudes are the reciprocal of one another. Since we are
 interested in their magnitudes, we adapt the solutions in the form
\begin{equation}
 x_{1,2} = \frac{\sqrt{5} \pm 1}{2}= \sqrt{1+0.5^2}\pm 0.5 \Longrightarrow
\begin{cases}x_1=1.618\ldots\\x_2=0.618\ldots \end{cases}\label{equ:aureo}
\end{equation}
 The larger number is called the \emph{golden number} and the smaller
 one the \emph{golden section}. 

 Luca Pacioli, by the turn of centuries XV–XVI, was the tutor of
 Guidubaldo, the son and heir of Federico di Montefeltro, Duke of
 Urbino\footnote{If you never visited this Renaissance city and its Ducal
 Palace, consider visiting it; it is one of the many UNESCO Heritage
 places.}; he wrote the famous book \emph{De Diuina Proportione} that
 contained also the theory of the golden section accompanied by beautiful
 drawings of many Platonic solids and other non convex ones, drawn by
 Leonardo da Vinci. Everything was executed with perfect etchings, even the
 construction of the golden section; in its basic form\footnote{The third
 formula in equation~\eqref{equ:aureo} is written in such a way as to
 explain the graphical construction in figure~\ref{fig:aureo}.} it is
 replicated in figure~\ref{fig:aureo}. 
\begin{figure}
\begin{Esempio}[\setfontsize{7}](0.40)
\unitlength=0.005\linewidth
\begin{picture}(170,140)(0,-70)
\GraphGrid(0,-70)(170,140)
\VECTOR(0,0)(170,0)
\Pbox(170,0)[t]{x}[0]
\Pbox(100,0)[t]{\mathrm{1}}[2]
\Pbox(0,0)[r]{O}[2]
\Arc(100,0)(50,0){-90}
\segment(100,0)(100,70)
\segment(0,0)(100,50)
\Pbox(50,0)[tr]{\mathrm{0.5}}[2]
\ModAndAngleOfVect100,50 to\M and\A 
\Arc(0,0)(\M,0){\A}\Pbox(\M,0)[bl]{C}[2]
\Arc(\M,0)(\M,-50){90}
\Arc(\M,0)(\M,-50){-90}
\Pbox(\fpeval{\M-50},0)[b]{\mathit{x_2}}[3]
\Pbox(\fpeval{\M+50},0)[b]{\mathit{x_1}}[3]
\put(\M,0){\Vector(-70:50)}
\Pbox(120,-25)[bl]{\mathit{r}=\mathrm{0.5}}[0]
\thicklines
\segment(0,0)(100,0)
\end{picture}
\end{Esempio}
\caption{The golden section $x_2$ and the golden number $x_1$}\label{fig:aureo}
\end{figure}
 By the way figure~\ref{fig:aureo} shows also the code that is used
 for the drawing done completely with the facilities available just with \pack{curv2e}. It is also a usage example of several commands. 

 Illiteracy was very widespread; books were expensive and were
 common just in the wealthy people mansions.

 Mathematicians in the classical times B.C. up to the artists in the
 Renaissance, had no other means but to use geometrical constructions with
 ruler and compass. Even today in schools where calculus is not yet
 taught as a normal subject, possibly not in certainly high school degree
 courses, but certainly not in elementary and junior high schools, the
 instructors have to recourse to geometrical constructions. Sometimes, as
 in Italy, access to public universities is open with no restrictions to
 all students with a high school diploma for degree courses that are 
 more vocational than cultural. Therefore such students in some university 
 degree courses have to frequent upgrading courses in order to master some 
 more mathematics compared to what they studied during their basic 
 education.

 The instructors nowadays very often prepare some booklets with their
 lessons; such documents, especially in electronic form, are a good help
 for many students. And \LaTeX is used to write such documents.
 Therefore this extension module is mostly dedicated to such instructors.

 The contents of this module is not exhaustive; it just shows a way to
 use the \pack{curve2e} facilities to extend it to be suited for the
 kind of geometry they teach.
 
 Here we describe the new commands provided by this package; then in
 section~\ref{sec:examples} we show their usage by means  examples.

\begin{enumerate}[noitemsep]
\item Command \cs{IntersectionOfLines} is a fundamental one; its syntax is
 the following:
\begin{ttsyntax}
\cs{IntersecionOfLines}\parg{point1}\parg{dir1} and\parg{point2}\parg{dir2}
\qquad to\meta{vector}
\end{ttsyntax}
 were each line is identified with its \meta{point} and its direction
 \meta{dir}; the intersection coordinates go to the output \meta{vector}.

\item A second command\cs{IntersectionOfSegments} does almost the same
 work, but the coordinates of a segment define also its direction,
 which is the argument of the difference of the terminal nodes of each
 segment; the syntax therefore is the following:
\begin{ttsyntax}
\cs{IntersectionOfSegments}\parg{point11}\parg{point12} 
\qquad and\parg{point21}\parg{point22}to\meta{vector}
\end{ttsyntax}
 Again the intersection point coordinates go to the output \meta{vector}.
 The first segment is between points 11 and 12, and, similarly, the second
 segment is between points 21 and 22.

\item Command \cs{ThreePointCircle} draws a circle that goes through three
 given points; the syntax is the following:
\begin{ttsyntax}
 \cs{ThreePointCircle}\meta{$\star$}\parg{point1}\parg{point2}\parg{point3}
\end{ttsyntax}
 A sub product of this macro is formed by the vector \cs{C} that contains
 the coordinates of the center of the circle, that might be useful even
 if the circle is not drawn; the optional asterisk, if present, does not
 draw the circle, but the center is available.

\item Alternatively
\begin{ttsyntax}\setfontsize{10.5}
 \cs{ThreePointCircleCenter}\parg{point1}\parg{point2}\parg{point3}to\meta{vector}
\end{ttsyntax}
 computes the three point circle center assigning its coordinates to
 \meta{vector}.

\item Command \cs{CircleWithCenter} draws a circle given its center and it
 radius; in facts the syntax is the following:
\begin{ttsyntax}
\cs{CircleWithCenter}\meta{center} Radius\meta{Radius}
\end{ttsyntax}
 This macro does not require the \cs{put} command to put the circle
 in place.

\item A similar macro \cs{Circlewithcenter} does almost the same; its
 syntax is the following:
\begin{ttsyntax}
\cs{Circlewithcenter}\meta{center} radius\meta{radius}
\end{ttsyntax}
 Apparently these two commands do the same, but, no, they behave
 differently: in the former command the \meta{Radius} is a vector the
 modulus of which si computed and used as the radius; in the latter
 command the \meta{radius} is a scalar and (its magnitude) is directly
 used.

\item Command with syntax:
\begin{ttsyntax}
\cs{AxisOf}\meta{point1} and\meta{point2} to \meta{point3} and\meta{point4}
\end{ttsyntax}
 is used to determine the axis of a segment; the given
 segment is specified with its end points \meta{point1} and \meta{point2}
 and the axis is determined by point \meta{point3} and \meta{point4};
 actually \meta{point3} is the middle point of the given segment.

\item These two commands with syntax:
\begin{ttsyntax}
\cs{SegmentCenter}\parg{point1}\parg{point2}to\meta{center}
\cs{MiddlePointOf}\parg{point1}\parg{point2}to\meta{center}
\end{ttsyntax}
 determine just the middle point between two given points. They are
 totally equivalent, aliases to one another; sometimes it is more
 convenient to use a name, sometimes the other; it helps reading the
 code and maintaining it.

\item Given a triangle  and a specific vertex, it is possible to determine
 the middle point of the opposite side; it is not very difficult, but it
 is very handy to have all the necessary elements to draw the median line.
 The simple syntax is the following:
\begin{ttsyntax}
\cs{TriangleMedianBase}\meta{vertex} on\meta{base1} and\meta{base2}
\qquad to\meta{base middle point}
\end{ttsyntax}

\item A similar command \cs{TriangleHeightBase} is used to determine the
 intersection of the height segment from one vertex to the opposite base;
 with triangles that have an obtuse angle, the height base might lay
 externally to one of the bases adjacent to such an angle. The syntax is
 the following
\begin{ttsyntax}
\cs{TriangleHeigthtBase}\meta{vertex} on\meta{base1} and\meta{base2} to\meta{height base}
\end{ttsyntax}

\item Similarly there is the \cs{TriangleBisectorBase} macro with
 a similar syntax:
\begin{ttsyntax}
\cs{TriangleBisectorBase}\meta{vertex} on\meta{base1} and\meta{base2}
\qquad to\meta{bisector base}
\end{ttsyntax}

\item A triangle \emph{barycenter} is the point where its median lines
 intersect; command \cs{TriangleBarycenter} determines its coordinates
 with the following syntax.
\begin{ttsyntax}
\cs{TriangleBarycenter}\parg{vertex1}\parg{vertex2}\parg{vertex3} to\meta{barycenter}
\end{ttsyntax}

\item A triangle \emph{orthocenter} is the point where its height lines
 intersect; command \cs{TriangleOrthocenter} determines its coordinates
 with the following syntax:
\begin{ttsyntax}
\cs{TriangleOrthocenter}\parg{vertex1}\parg{vertex2}\parg{vertex3} to\meta{orthocenter}
\end{ttsyntax}

\item A triangle \emph{incenter} is the point where its bisector lines
 intersect; command \cs{TriangleIncenter} determines its coordinates
 with the following syntax:
\begin{ttsyntax}
\cs{TriangleIncenter}\parg{vertex1}\parg{vertex2}\parg{vertex3} to\meta{incenter}
\end{ttsyntax}

\item The distance of a specified point from a given segment or line is
 computed with the following command
\begin{ttsyntax}
\cs{DistanceOfPoint}\meta{point} from\parg{point1}\parg{point2} to\meta{distance}
\end{ttsyntax}
 where \meta{point} specifies the point and \meta{point1} and \meta{point2}
 identify two points on a segment or a line; \meta{distance} is a scalar
 value.

\item In a construction that will be examined in section~\ref{sec:examples}
 we need to determine an ellipse axis if the other axis and the focal
 distance are know; actually it solves the relation
\begin{equation}a^2= b^2 +c^2\label{equ:axes-foci}\end{equation}
 that connects such three quantities; $a$ is always the largest of the
 three quantities; therefore the macro tests if the first entry is larger
 than the second one: if is is, it computes a Pitagorean difference,
 otherwise the user should pay attention to use as the first entry the
 smaller among $b$ and $c$, so as to compute a Pitagorean sum. The command
 is the following:
\begin{ttsyntax}
\cs{AxisFromAxisAndFocus}\meta{axis or focus} and\meta{focus or axis} 
\qquad to\meta{other axis or focus}
\end{ttsyntax}
 The word “axis” stands for “semi axis length”; the word “focus" stands
 for “focal semi distance”; actually the macro works equally well with
 full lengths, instead of half lengths; its is important not to mix
 full and half lengths. Such lengths are expressed as factors of
 \cs{unitlength}, not as absolute values. This command is described 
 again when dealing with the specific problem referred to at the 
 beginning of this list item;  the description is going to be more 
 detailed and another macro is added to avoid possible errors.

\item Given a segment, i.e. the coordinates of its end points, it is
 useful to have a macro that computes its length; at the same time it is
 useful to to compute its direction; this operation is not the same as to
 compute modulus and argument of a vector, but consists in computing such
 quantities from the difference of the vectors pointing to the segment
 end points. These two macros are the following:
\begin{ttsyntax}
\cs{SegmentLength}\parg{point1}\parg{point2} to\meta{length}
\cs{SegmentArg}\parg{point1}\parg{point2} to\meta{argument}
\end{ttsyntax}
 The \meta{argument} is computed in the interval $-180^\circ < \phi \leq
 +180^\circ$; it represents the argument of the vector that goes from
 \meta{point1} to \meta{point2}, therefore the user must pay attention to
 the order s/he enters the end point coordinates.

\item The next command \cs{SymmetricalPointOf} is used to find the
 reflection of a specified point with respect to a fixed point; of course
 the latter is the middle point of the couple, but the unknown to be
 determined is not the center of a segment, but one of its end points.
 The syntax is the following:
\begin{ttsyntax}
\cs{SymmetricalPointOf}\meta{point1} respect\meta{fixed} to\meta{point2}
\end{ttsyntax}

\item  Command \cs{RegPolygon} draws a regular polygon inscribed within
 a circle of given radius and center, with a specified number of sides;
 optional arguments allow to  specify color and thickness of the sides,
 or the polygon interior color; this macro operates differently from the 
 one for drawing ellipses, that draws simultaneously an ellipse with
 the border of a color and the interior of another one; with this macro the
 user who wants to achieve this effect must superimpose to polygons with
 different settings; but it would not be too difficult to arrange a new
 macro or to modify this one in order to get “bicolor” polygons.
 It is not necessary for the purpose of this package, therefore we
 let the user express his/her phantasy by creating other macros. The actual
 syntax is the following:
\begin{ttsyntax}
\cs{RegPolygon}\meta{$\star$}\parg{center}\marg{radius}\marg{sides}\oarg{angle}\aarg{settings}
\end{ttsyntax}
 The initial optional asterisk specifies if the interior has to be
 coloured; if yes, the \meta{settings} refer to the color of the
 interior; if not, the \meta{settings} refer to the thickness and
 color of the sides; no \meta{settings} imply sides drawn with the
 default line thickness, generally the one corresponding to \cs{thinlines},
 and the default color (generally black) for the sides or the interior.
 By default the first vertex is set to an angle of $0^\circ$ with
 respect to the \meta{center}; the optional \meta{angle} modifies
 this value to what is necessary for a particular polygon. The
 \meta{center} itself is optional, in the sense that if it is not
 specified the center lays in the origin of the \env{picture} axes; if this 
 argument is specified, the polygon center is displaced accordingly.
 The number of sides in theory may be very high, but it is not wise
 to exceed a couple of dozen sides; if the number of sides is too
 high, a polygon (completely contained in an A4 page) may become undistinguishable from a circumference.

\item Several macros are dedicated to ellipses; their names are spelled
 in Italian, “ellisse”, because the name “ellipse” is already taken by
 other packages; with an Italian user command names there should be no
 interference with other packages, or the risk is reduced to
 a minimum. The various macros are \cs{ellisse}, \cs{Sellisse},
 \cs{Xellisse}, \cs{XSellisse}, \cs{EllisseConFuoco} \cs{EllisseSteiner};
 the last two control sequence names are aliased with the corresponding
 English ones \cs{EllipseWithFocus} and \cs{SteinerEllipse}. For the
 other four ones it is wise to avoid English names for the reasons
 explained above. After all the Italian  and the English names are very
 similar and are pronounced almost identically.

 {\tolerance=3000 Actually \cs{ellisse} is practically a shorthand for 
 \cs{Sellisse} because some optional arguments are already fixed, but the 
 meaning of \cs{fillstroke} depends on the presence or absence of an 
 initial asterisk; similarly \cs{Xellisse} is a sort of a shorthand for
 \cs{XSellisse}; in facts those commands, that contain  an ‘S’ in their 
 names, can optionally perform also the affine \emph{shear} transformation,
 while those without the ‘S’ do not execute such transformation. 
 Figure~\ref{fig:shear} displays a normal ellipse  with its bounding 
 rectangle, and the same ellipse to which the shear affine transformation 
 is applied; the labeled points represent the third order Bézier spline 
 nodes and control points.\par}
\begin{figure}[!htb]
\dimendef\Wmp=2000 \Wmp=\dimexpr(\textwidth-\columnsep)/2\relax
\begin{minipage}{\Wmp}\centering
\unitlength=0.007\linewidth
\begin{picture}(100,70)(-50,-35)
\XSellisse(0,0){50}{25}*
\end{picture}
\end{minipage}
\hfill
\begin{minipage}{\Wmp}\centering
\unitlength=0.007\linewidth
\begin{picture}(100,70)(-50,-35)
\XSellisse(0,0)<20>{50}{25}*
\end{picture}
\end{minipage}
\caption{The effect of shearing an ellipse with its bounding rectangle}\label{fig:shear}
\end{figure}

\item The syntax of those six commands are the following:
\begin{ttsyntax}
\cs{Sellisse}\meta{$\star$}\marg{semiaxis-h}\marg{semiaxis-v}\oarg{shear}
\cs{ellisse}\meta{$\star$}\marg{semiaxis-h}\marg{semiaxis-v}
\cs{XSellisse}\meta{$\star$}\parg{center}\oarg{angle}\aarg{shear}\marg{semiaxis-h}\%
\qquad \marg{semiaxis-v}\meta{$\star$}\oarg{settings1}\oarg{settings2}
\cs{Xellisse}\meta{$\star$}\parg{center}\oarg{angle}\marg{semiaxis-h}\%
\qquad\marg{semiaxis-v}\oarg{settings1}\marg{settings2}
\cs{EllipseWithFocus}\meta{$\star$}\parg{vertex1}\parg{vertex2}\parg{vertex3}\parg{focus}
\cs{SteinerEllipse}\meta{$\star$}\parg{vertex1}\parg{vertex2}\parg{vertex3}\oarg{diameter}
\end{ttsyntax}
 All require the semi axis lengths; the \meta{semiaxis-h} and
 \meta{semiaxis-v} refer to the semi axes before possible rotation by
 \meta{angle} degrees, and do not make assumptions on which axis is the
 bigger one. The optional parameter \meta{shear} is the angle in degrees
 by which the vertical coordinate lines are slanted by effect of shearing. 
 If \meta{shear}, that by default equals zero, is not set
 to another value, the asterisks of command \cs{Sellisse} and
 \cs{XSellisse} do not have any effect. Otherwise the asterisk of
 \cs{Sellisse} forces to draw the ellipse bounding box (rectangle before
 shearing, parallelogram after shearing) as shown together with some
 marked special points (the vertices, spline nodes and control points
 of the quarter circle or quarter ellipse Bézier splines) in 
 figure~\ref{fig:shear}.
 For \cs{ellisse} the asterisk implies filling, instead of stroking the
 ellipse contour.
 The \meta{setting}~1 and~2 refer to the color filling and/or border
 color, and contour thickness, as already explained. For the
 \cs{EllipseWithFocus}, the \meta{focus} contains the coordinates
 of one of the two ellipse foci; such coordinates should point to
 some position \emph{inside} the triangle. The \cs{SteinerEllipse}
 requires less data, in the sense that such ellipse is unique; it
 is the ellipse internally tangent to the triangle at its side middle
 points.

\end{enumerate}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Examples}\label{sec:examples}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Here we can show some examples of the advanced \pack{curve2e} commands
 and of what can be done with this \pack{euclideangeometry} extension.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Straight and curved vectors}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 
 Figure~\ref{fig:vectors} shows some vectors and vector arcs with the
 code used to draw them; as usual some points are described with cartesian
 coordinates and some with polar ones.

\begin{figure}[!htb]
\begin{Esempio}[\setfontsize{8.5}](0.45)
\unitlength=0.01\linewidth
\begin{picture}(100,60)
\GraphGrid(100,60)
\put(0,30){\vector(1,2){10}}
\put(20,30){\Vector(10,20)}
\VECTOR(40,30)(50,50)
\VVECTOR(60,30)(70,60)
\Arc(100,60)(80,60){90}
\VectorArc(0,0)(20,0){90}
\VectorARC(100,0)(80,0){-90}
\polyvector(30,0)(35,10)(55,20)(60,0)
\end{picture}
\end{Esempio}
\caption{Some vectors and vector arcs}\label{fig:vectors}
\end{figure}


\begin{figure*}[!tb]
\begin{Esempio}*[\setfontsize{10}]\centering
\unitlength=0.006\linewidth\begin{picture}(120,90)
%
\RegPolygon(9,20){20}{6}<\linethickness{3pt}\color{red}> 
\RegPolygon(55,20){20}{7}[90]
\RegPolygon(100,20){20}{8}[22.5]<\linethickness{0.5ex}\color{blue}>
%
\put(0,50){%
  \RegPolygon(9,20){20}{3}\RegPolygon(9,20){20}{3}[30]
  \RegPolygon(9,20){20}{3}[60]\RegPolygon(9,20){20}{3}[90]
%
  \RegPolygon*(55,20){20}{4}<\color{green}>
  \RegPolygon(55,20){20}{4}<\linethickness{1ex}>
%
  \RegPolygon*(100,20){20}{4}[45]<\color{orange}>
  \RegPolygon(100,20){20}{4}[45]<\linethickness{1ex}\color{blue}>
}
\end{picture}
\end{Esempio}
\caption{A variety of polygons and their codes}\label{fig:variety-of-polygons}
\end{figure*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Polygons}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Figures~\ref{fig:pentagon} and~\ref{fig:filled-pentagon} display
 a normal and a color filled pentagon with their codes.
 Figure~\ref{fig:variety-of-polygons} shows a variety of polygons
 with their codes.

\begin{figure}[!htb]
\begin{Esempio}[\setfontsize{10}](0.8)
\unitlength=0.5mm
\begin{picture}(40,32)(-20,-17)
\polyline(90:20)(162:20)(234:20)(306:20)(378:20)(90:20)
\end{picture}
\end{Esempio}
\caption{A normal polygon drawn with \cs{polyline}}
\label{fig:pentagon}
\end{figure}


\begin{figure}[!htb]
\begin{Esempio}[\setfontsize{10}](0.8)
\unitlength=.5mm
\begin{picture}(40,32)(-20,-20)
\color{magenta}
\polygon*(90:20)(162:20)(234:20)(306:20)(378:20)
\end{picture}
\end{Esempio}
\caption{A filled polygon drawn with \cs{polygon}}
\label{fig:filled-pentagon}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \subsection{Dashed and dotted lines}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 For dotted lines it is possible to specify the dot size;
 it can be specified with an explicit unit of measure, or, if no unit is
 specified, it is assumed to be “points”. The \cs{Dotline} takes care
 of transforming the implied or the explicit dimension in multiples of
 \cs{unitlength}. Figure~\ref{fig:DashDot} shows some examples with their
 codes.

\begin{figure}[!htb]
\begin{Esempio}[\setfontsize{10}](0.45)
\unitlength=0.02\linewidth
\begin{picture}(40,40)
\GraphGrid(40,40)
\Dashline(0,0)(40,10){4}
\put(0,0){\circle*{1}}
\Dashline(40,10)(0,25){4}
\put(40,10){\circle*{1}}
\Dashline(0,25)(20,40){4}
\put(0,25){\circle*{1}}
\put(20,40){\circle*{1}}
\Dotline(0,0)(40,40){2}[0.75mm]
\put(40,40){\circle*{1}}
\end{picture}
\end{Esempio}
\caption{Dashed and dotted lines}\label{fig:DashDot}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Generic curves}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
With the \cs{Curve} macro it is possible to make line art or filled shapes. Figures~\ref{fig:hearts} show the same shape, the first just stroked and the second color filled. 

\begin{figure}[!htp]
\begin{Esempio}[\setfontsize{9}](0.65)
\unitlength=8mm\relax
\begin{picture}(5,5)
\put(0,0){\framebox(5,5){}}\thicklines\roundcap
\Curve(2.5,0)<0.1,1>(5,3.5)<0,1>%
  (4,5)<-1,0>(2.5,3.5)<-0.1,-1.2>[-0.1,1.2]%
  (1,5)<-1,0>(0,3.5)<0,-1>(2.5,0)<0.1,-1>
\end{picture}
\end{Esempio}

\vspace*{2\baselineskip}

\begin{Esempio}[\setfontsize{9}](0.65)
\unitlength=8mm\relax
\begin{picture}(5,5)
\put(0,0){\framebox(5,5){}}\thicklines\roundcap
\color{orange}\relax
\Curve*(2.5,0)<0.1,1>(5,3.5)<0,1>%
(4,5)<-1,0>(2.5,3.5)<-0.1,-1.2>[-0.1,1.2]%
(1,5)<-1,0>(0,3.5)<0,-1>(2.5,0)<0.1,-1>
\end{picture}
\end{Esempio}
\caption{A stroked and a filled heart shaped contour}
\label{fig:hearts}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The \cs{multiput} command}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

 The new \cs{multiput} and \cs{xmultiput} commands are extensions of the 
 original \cs{multiput} macro; both are used to put a number of objects 
 according to a discrete law; but they can produce surprising effects. 
 Figure~\ref{fig:multiput} displays several examples. As it possible 
 to see, the black dots are evenly distributed along the canvas diagonal; 
 the green filled squares are along a sloping down line inclined by 
 $15^\circ$ as specified by the polar coordinates of the \meta{increment}; 
 the blue filled triangles are distributed along a parabola; the red 
 stroked diamonds are distributed along a half sine wave.

\noindent\begin{figure}[!htb]
\begin{Esempio}[\setfontsize{8}](0.55)
\unitlength=0.01\linewidth
\begin{picture}(100,100)
\GraphGrid(100,100)
\multiput(0,0)(10,10){11}{\circle*{2}}
\color{blue!70!white}
\multiput(0,0)(10,0){11}{%
\RegPolygon*{2}{3}<\color{blue!70!white}>}%
  [\GetCoord(\R)\X\Y
  \edef\X{\fpeval{\X+10}}
  \edef\Y{\fpeval{(\X/10)**2}}
  \CopyVect\X,\Y to\R]
\multiput(0,0)(10,1){11}{%
\RegPolygon{2}{4}<\color{magenta}>}%
  [\GetCoord(\R)\X\Y
   \edef\X{\fpeval{\X+10}}
   \edef\Y{\fpeval{sind(\X*1.8)*100}}
   \CopyVect\X,\Y to\R]
\multiput(50,50)(-15:5){11}{%
\RegPolygon*{2}{4}[45]<\color{green!60!black}>}
\end{picture}
\end{Esempio}
\caption{Some examples of the \meta{handler} optional argument}
\label{fig:multiput}
\end{figure}

 Another interesting construction is a clock quadrant; this is shown
 in figure~\ref{fig:orologio}

\begin{figure}[!htb]
\begin{Esempio}[\setfontsize{9.5}](0.525)
\unitlength=0.0095\linewidth
\begin{picture}(100,100)
\GraphGrid(100,100)
\put(50,50){\thicklines\circle{100}}
\xmultiput[50,50](60:35)(-30:1){12}%
  {\makebox(0,0){\circle*{2}}}%
    [\MultVect\R by\D to\R]% 
\xmultiput[50,50](60:40)(-30:1){12}%
  {\ArgOfVect\R to\Ang
    \rotatebox{\fpeval{\Ang-90}}%
    {\makebox(0,0)[b]{%
       \Roman{multicnt}}}}%
      [\Multvect{\R}{\D}\R]
\thicklines\put(50,50){\circle*{4}}
\put(50,50){\Vector(37.5:30)}
\put(50,50){\Vector(180:33)}
\end{picture}
\end{Esempio}
\caption{Usage example of the \texttt{\string\xmultiput} command}
\label{fig:orologio}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \subsection{Drawing mathematical functions}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

 Figure~\ref{fig:iperbole} shows an equilateral hyperbola; since it
 has asymptotes, the drawing must be carefully done avoiding overflows,
 parts of drawing out of the \env{picture} area. Nevertheless
 the possibility of describing mathematical functions in terms of L3
 functions (in spite of the same name, they are completely different
 things) makes it possible to exploit the \meta{settings} argument to
 do the job with \cs{xmultiput}.

\begin{figure*}[!tp]
\begin{Esempio}[\setfontsize{9}](0.5)%
\unitlength=0.008\linewidth
\begin{picture}(100,100)
\GraphGrid(100,100)
\VECTOR(0,0)(100,0)\Pbox(100,0)[tr]{x}[0]
\VECTOR(0,0)(0,100)\Pbox(0,100)[tr]{y}[0]
\Pbox(0,0)[r]{O}[3pt]
\thicklines
\moveto(10,100)\countdef\I=2560 \I=11
\xmultiput(0,0)(1,0){101}%
  {\lineto(\I,\fpeval{1000/\I})}%
  [\advance\I by1 \value{multicnt}=\I]
\strokepath
\end{picture}
\end{Esempio}
\caption{An equilateral hyperbola drawn with a thinly sampled piecewise
 continuous line}\label{fig:iperbole}
\end{figure*}

 A more complicated drawing can be done by expressing the function to draw
 with parametric equations; the idea is to code the math formulas
\[\begin{cases}
x(t) = f_1(t)\\
y(t) = f_2(t)
\end{cases}\]
because it is easy to code the $x$ and the $y$ component and use the
 \cs{fpdowhile} command to trace the curve with a piecewise continuous
 line; actually a continuous line with a piecewise continuous derivative;
 it is important to sample the curve in a sufficient dense way.
 A heart shaped mathematical function taken from the internet
 \footnote{\url{http://mathworld.wolfram.com/HeartCurve.html} reports 
 several formulas, including the cardioid, but the one we use here is 
 a different function} is the following
\begin{align*}
x(t) &= \sin^3(t)\\
y(t) &= \dfrac{13\cos(t)-5\cos(2t)-2\cos(3t)-\cos(4t)}{16}
\end{align*}
 Figure~\ref{fig:math-heart} displays the graph, and its code, and, most
 important, the L3 definition of the parametric equations. Compared to
 the previous equations we applied a scale factor and added the final
 term \texttt(2.4) in order to shift a little bit the drawing so as to
 vertically center it . 

\begin{figure*}[!tbp]
\begin{minipage}{\textwidth}
\def\codefraction{0.5}
\dimendef\Wuno=2000 \Wuno=\codefraction\textwidth
\dimendef\Wdue=2002 \Wdue=\dimexpr\textwidth-\columnsep-\Wuno\relax
\begin{minipage}{\Wuno}\setfontsize{6.9}%
\begin{verbatim}
%              Parametric equations of the "heart"
\providecommand\heart[3]{%
\edef\X{\fpeval{#1*16*(sind(#2)^3)}}
\edef\Y{\fpeval{#1*(13*cosd(#2) - 5*cosd(2*#2) 
  - 2*cosd(3*#2) -cosd(4*#2)+2.4)}}
\CopyVect\X,\Y to#3}
%
%                                         Drawing
\unitlength=0,005\linewidth
\begin{picture}(200,200)(-100,-100)
\GraphGrid(-100,-100)(200,200)
\VECTOR(-100,0)(100,0)\Pbox(100,0)[tr]{x}[0]
\VECTOR(0,-100)(0,100)\Pbox(0,100)[tl]{y}[0]
\Pbox(0,0)[tr]{O}\linethickness{1pt}\bgroup
\edef\scala{\fpeval{100/16}}
\countdef\I=2560 \I=0\roundjoin
\fpdowhile{\I !>360}{\heart\scala\I\Punto
\ifnum\I=0 \moveto(\Punto)\else \lineto(\Punto)\fi
\advance\I by 3}\strokepath\egroup
\end{picture}\end{verbatim}
\end{minipage}
\hfill
\begin{minipage}{\Wdue}\raggedleft
\setfontsize{8}%
%
\providecommand\heart[3]{%
\edef\X{\fpeval{#1*16*(sind(#2)^3)}}
\edef\Y{\fpeval{#1*(13*cosd(#2) - 5*cosd(2*#2) 
  - 2*cosd(3*#2) -cosd(4*#2)+2.4)}}
\CopyVect\X,\Y to#3}
%
\unitlength=0,005\linewidth
\begin{picture}(200,200)(-100,-100)
\GraphGrid(-100,-100)(200,200)
\VECTOR(-100,0)(100,0)\Pbox(100,0)[tr]{x}[0]
\VECTOR(0,-100)(0,100)\Pbox(0,100)[tl]{y}[0]
\Pbox(0,0)[tr]{O}\linethickness{1pt}\bgroup
\edef\scala{\fpeval{100/16}}
\countdef\I=2560 \I=0\roundjoin
\fpdowhile{\I !>360}{\heart\scala\I\Punto
\ifnum\I=0 \moveto(\Punto)\else \lineto(\Punto)\fi
\advance\I by 3}\strokepath\egroup
\end{picture}
\end{minipage}
\end{minipage}
\caption{A heart shaped mathematical function drawn with a thinly sampled
 piecewise continuous line}\label{fig:math-heart}
\end{figure*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Triangles and their special lines}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

 Triangles have special lines; they are the median, the height, and the
 bisector lines. They join each vertex with a specific point of the
 apposite side, respectively with the middle point, the intersection 
 with the side perpendicular line, and the intersection with the bisector 
 line. Figure~\ref{fig:MHBlines}  displays the construction of the three 
 special lines relative to a specific vertex. Thanks to the macros 
 described earlier in this list, this drawing is particularly simple; most
 of the code is dedicated to labelling the various points and to
 assign coordinate values to the macros that are going to be use 
 in a symbolic way. The generic triangle (not a regular polygon) requires 
 one line of code, and the determination of the intersections of the lines
 with the suitable triangle side, and their tracing requires two code lines
 each.

\begin{figure}[!tb]\centering
\begin{Esempio}[\setfontsize{6.9}](0.4)
\unitlength=0.008\linewidth
\begin{picture}(100,100)(0,-10)
\GraphGrid(0,-10)(100,100)
\def\Puno{0,0} \def\Pdue{0,80} \def\Ptre{100,60}
 {\thicklines\polygon(\Puno)(\Pdue)(\Ptre)}%
 \Pbox(\Puno)[tc]{P_1}[1]
\Pbox(\Pdue)[bc]{P_2}[1]\Pbox(\Ptre)[bc]{P_3}[1]
 % Median
 \TriangleMedianBase\Puno on \Pdue and \Ptre to\M
 \Pbox(\M)[bc]{M}[1.5]\segment(\Puno)(\M)
% Height
 \TriangleHeightBase\Puno on \Pdue and\Ptre to\H
 \Dotline(\Puno)(\H){2}[1.5]\Pbox(\H)[bc]{H}[1.5]
% Bisector
 \TriangleBisectorBase\Puno on\Pdue and\Ptre to\B
 \Dashline(\Puno)(\B){3}\Pbox(\B)[b]{B}[1.5]
\end{picture}
\end{Esempio}
\caption{A triangle with the median, the height, and the bisector lines
 from a specific vertex}\label{fig:MHBlines}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \subsection{Special triangle centers}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 Each triplet of a triangle special lines of the same kind intersect each
 other in a special point; the median lines intersect in the
 \emph{barycenter}, the height lines in the \emph{orthocenter}, the 
 bisectors lines in the \emph{incenter}; these centers may be those of 
 special circles: Figures~\ref{fig:barycenter} to~\ref{fig:circumcenter}; 
 the \emph{incircle}, centred in the incenter,
 has a special name, because it has the property of being tangent to all
 the three triangle sides; there is also the circumcircle that passes
 through the three vertices, its center is the intersection of the
 three side axes. There is also the \emph{nine point circle}.
 Figures~\ref{fig:barycenter}, \ref{fig:orthocenter}, \ref{fig:incenter},
 and~\ref{fig:circumcenter} display the necessary constructions and,
 possibly, also the special circles they are centers of.

\begin{figure}[!htb]
\begin{Esempio}[\setfontsize{6.5}](0.45)
\unitlength=0.008\linewidth
\begin{picture}(100,100)(0,-10)
\GraphGrid(0,-10)(100,100)
\def\Puno{0,0}\def\Pdue{0,80}\def\Ptre{100,60}
{\linethickness{0.6pt}\polygon(\Puno)(\Pdue)(\Ptre)}%
\Pbox(\Puno)[tl]{P_1}[1.5]%
\Pbox(\Pdue)[bl]{P_2}[1.5]\Pbox(\Ptre)[bc]{P_3}[1.5]
 \TriangleMedianBase\Puno on\Pdue and \Ptre to\Mu
 \TriangleMedianBase\Pdue on\Ptre and \Puno to\Md
 \TriangleMedianBase\Ptre on\Puno and \Pdue to\Mt
\Dotline(\Puno)(\Mu){3}[1.5]
\Dotline(\Pdue)(\Md){3}[1.5]
\Dotline(\Ptre)(\Mt){3}[1.5]
\IntersectionOfSegments(\Puno)(\Mu)and(\Pdue)(\Md)to\C
\Pbox(\C)[t]{B}[2]
\end{picture}
\end{Esempio}
\caption{Determination of the barycenter}\label{fig:barycenter}
\end{figure}

\begin{figure}[!htb]
\begin{Esempio}[\setfontsize{6.5}](0.45)
\unitlength=0.008\linewidth
\begin{picture}(100,100)(0,-10)
\GraphGrid(0,-10)(100,100)
\def\Puno{0,0}\def\Pdue{0,80}\def\Ptre{100,60}
{\linethickness{0.6pt}\polygon(\Puno)(\Pdue)(\Ptre)}%
\Pbox(\Puno)[tl]{P_1}[1.5]%
\Pbox(\Pdue)[bl]{P_2}[1.5]\Pbox(\Ptre)[bc]{P_3}[1.5]
 \TriangleHeightBase\Puno on\Pdue and \Ptre to\Hu
 \TriangleHeightBase\Pdue on\Ptre and \Puno to\Hd
 \TriangleHeightBase\Ptre on\Puno and \Pdue to\Ht
\Dotline(\Puno)(\Hu){3}[1.5]
\Dotline(\Pdue)(\Hd){3}[1.5]
\Dotline(\Ptre)(\Ht){3}[1.5]
\IntersectionOfSegments(\Puno)(\Hu)and(\Pdue)(\Hd)to\C
\Pbox(\C)[t]{H}[2]
\end{picture}
\end{Esempio}
\caption{Determination of the orthocenter}\label{fig:orthocenter}
\end{figure}

\begin{figure}[!htb]
\begin{Esempio}[\setfontsize{6}](0.45)
\unitlength=0.008\linewidth
\begin{picture}(100,100)(0,-10)
\GraphGrid(0,-10)(100,100)
\def\Puno{0,0}\def\Pdue{0,80}\def\Ptre{100,60}
{\linethickness{0.6pt}%
  \polygon(\Puno)(\Pdue)(\Ptre)}%
\Pbox(\Puno)[tl]{P_1}[1.5]%
\Pbox(\Pdue)[bl]{P_2}[1.5]
\Pbox(\Ptre)[bc]{P_3}[1.5]
 \TriangleBisectorBase\Puno on\Pdue and \Ptre to\Iu
 \TriangleBisectorBase\Pdue on\Ptre and \Puno to\Id
 \TriangleBisectorBase\Ptre on\Puno and \Pdue to\It
\Dotline(\Puno)(\Iu){3}[1.5]
\Dotline(\Pdue)(\Id){3}[1.5]
\Dotline(\Ptre)(\It){3}[1.5]
\IntersectionOfSegments(\Puno)(\Iu)%
  and(\Pdue)(\Id)to\C
\Pbox(\C)[t]{I}[2]
\DistanceOfPoint\C from(\Puno)(\Pdue)to\R
\Circlewithcenter\C radius\R
\end{picture}
\end{Esempio}
\caption{Determination of the incenter and of the incircle}\label{fig:incenter}
\end{figure}

\begin{figure}[!htb]
\begin{Esempio}[\setfontsize{6.25}](0.45)
\unitlength=0.01\linewidth
\begin{picture}(100,110)
\GraphGrid(100,110)
\CopyVect20,10to\Pu \Pbox(\Pu)[t]{P_1}
\CopyVect10,90to\Pd \Pbox(\Pd)[br]{P_2}
\CopyVect100,70to\Pt \Pbox(\Pt)[l]{P_3}
{\linethickness{0.6pt}\polygon(\Pu)(\Pd)(\Pt)}%
\AxisOf\Pd and\Pu to\Mu\Du 
\AxisOf\Pu and\Pt to\Md\Dd
\AxisOf\Pt and\Pd to\Mt\Dt
\IntersectionOfLines(\Mu)(\Du)and(\Md)(\Dd)to\C
\AddVect\Mu and\Du to\Du\Dotline(\Mu)(\Du){3}[2]
\AddVect\Md and\Dd to\Dd\Dotline(\Md)(\Dd){3}[2]
\AddVect\Mt and\Dt to\Dt\Dotline(\Mt)(\Dt){3}[2]
\Pbox(\C)[t]{C}[2.5]
\ThreePointCircle*(\Pu)(\Pd)(\Pt)
\end{picture}\end{Esempio}
\caption{Determination of the circumcenter and of the circumcircle}\label{fig:circumcenter}
\end{figure}

 Although these examples require some new simple macros, described
 in the previous sections; some more more examples can be made that require 
 more complex macros. Even these macros are just examples. For other
 applications it is probably necessary to add even more macros.

 Let us proceed with the construction of the Steiner ellipse: given a
 triangle, there exists only one ellipse that is internally tangent to
 the side middle points.

 The geometrical construction goes on this way; suppose you have to draw
 the Steiner ellipse of triangle $T$; finding the side middle points
 has already been shown, but the process to build the ellipse is still
 to be found. So let us chose a side to work as the base of triangle $T$,
 and perform an affine shear transformation parallel to the base 
 so as to move the vertex of triangle $T$, opposite to the base, to the
 base axis, we get another triangle $T_1$ that is isosceles; if it is
 not yet so, let us make another compression/expansion affine
 transformation, so as to get an equilateral triangle $T_2$; this last
 triangle is particularly simple to handle, because its Steiner ellipse
 reduces to its incircle. If we apply in reverse order the above
 transformations we get the Steiner ellipse we were looking for.
 The only difficult part is the affine shear transformation. 

 The L3 functions we already created take care of all such
 transformations, but with an optional asterisk we can draw the
 intermediate passages where triangles $T_2$ and $T_1$ have their base
 shifted and rotated to be horizontal, so that some translations and
 rotations are also necessary. Figure~\ref{fig:Steiner-finale} displays
 the final result and the code necessary to build it.

\begin{figure}[!htb]
\begin{Esempio}[\setfontsize{8}](0.5)
\unitlength=0.01\linewidth
\begin{picture}(100,110)
\GraphGrid(100,110)%
\SteinerEllipse(10,10)(90,20)(60,105)[2]
\end{picture}\end{Esempio}
\caption{The Steiner ellipse of a given triangle}
\label{fig:Steiner-finale}
\end{figure}

 With just the addition of an asterisk we can draw the whole geometrical
 construction; see figure~\ref{fig:Steiner-intermedio}

\begin{figure}[!htb]
\begin{Esempio}[\setfontsize{8}](0.5)
\unitlength=0.01\linewidth
\begin{picture}(100,110)(0,-10)
\GraphGrid(0,-10)(100,110)%
\SteinerEllipse*(10,10)(90,20)(60,105)[2]
\end{picture}\end{Esempio}
\caption{The construction of the Steiner ellipse of a given triangle}
\label{fig:Steiner-intermedio}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{A triangle internally tangent ellipse given one of its foci}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

 It is possible to draw an ellipse that is internally tangent to
 a triangle if one of its foci is specified; without this specification
 the problem is not definite, and the number o such ellipses is countless.
 But with the focus specification, just one ellipse exists with that
 tangency constraint. It suffices to find the other focus and at least
 one point of tangency, because the focal distance and the sum of
 distances of that tangency point from the foci, is sufficient to
 determine all the parameters required to draw the ellipse.

\begin{figure}[!tb]\centering
\begin{Esempio}[\setfontsize{7}](0.375)
\unitlength=0.0065\linewidth
\begin{picture}(150,150)(-30,-20)
\GraphGrid(-30,-20)(150,150)
\EllipseWithFocus%
  (10,40)(110,10)(0,110)(20,60)
\end{picture}\end{Esempio}
\caption{An ellipse internally tangent to a triangle, given a focus}
\label{fig:ellisse-interna-finale}
\end{figure}

\begin{figure}[!tb]
\begin{Esempio}[\setfontsize{7}](0.375)
\unitlength0.0065\linewidth
\begin{picture}(150,150)(-30,-20)
\GraphGrid(-30,-20)(150,150)
\EllipseWithFocus*%
  (10,40)(110,10)(0,110)(20,60)
\end{picture}\end{Esempio}
\caption{Construction of the ellipse of figure~\ref{fig:ellisse-interna-finale}}\label{fig:ellisse-interna}
\end{figure}


 The geometrical construction is rather complicated; the steps to follow
 are the following:\enlargethispage*{\baselineskip}
\begin{itemize}[noitemsep]

\item draw the triangle and the given focus $\mathsf{F}$;

\item Find the symmetrical points $\mathsf G_i$ of this focus with 
 respect to the sides of the triangle;

\item use these three points $\mathsf G_i$ as the vertices of a triangle
 with which to draw its circumcircle, actually only its center is of
 interest, because it represents the second focus $\mathsf F'$; the
 inter focal distance  $2c$; is just le length of vector $F' -F$;

\item join with segments each symmetrical point $\mathsf G_i$ with the
 second focus $\mathsf F'$ and find their intersections $\mathsf T_i$
 with the triangle sides; they represent the tangency points of the
 ellipse to be drawn;

\item use one of these tangency points to find its distances from the
 foci; their sum gives the ellipse larger axis length $2a$;

\item equation~\eqref{equ:axes-foci} allows to find the second axis
 length; the segment that joins the foci has the required inclination
 of the main axis; its middle point is the ellipse center; therefore all
  necessary pieces of information to draw the ellipse are known.

\end{itemize}
 Figures~\ref{fig:ellisse-interna-finale} and~\ref{fig:ellisse-interna}
 display the construction steps and the final result.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 \section{Conclusion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
 We have shown that the \amb{picture} environment, extended with
 this package \pack{euclideangeometry} (that takes care of loading
 \pack{curve2e} and \pack{pict2e}) can make important diagrams that
 certainly were not foreseen by Leslie Lamport when he first wrote the
 code for the initial \env{picture} environment.
 
 The reader can easily understand that this package is far from being
 exhaustive for all geometrical problems to be solved with ruler and
 compass; it shows a way to add more commands to approach further problems;
 if any author, who creates new commands, would like to  contribute more
 macros to this package, I will be happy to integrate his/her contribution
 to a new version of this package; depending on the contribution, I would
 be very happy to add its author name to this  package author list; for
 simpler contributions each contributor will be duly acknowledged.

 Creating new macros to solve more problems is pleasant; the more
 difficult the problem, the greater the satisfaction in solving it.


\begin{center}
 Have fun with \LaTeX and its potential applications!
\end{center}

\end{document}