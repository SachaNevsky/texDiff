%!PS-Adobe-2.0 EPSF-2.0
%%Creator: dvips(k) 5.97 Copyright 2008 Radical Eye Software
%%Title: wieesgeht.dvi
%%CreationDate: Sun May 31 12:40:54 2009
%%BoundingBox: 135 381 525 664
%%DocumentFonts: LucidaBright-Demi LucidaBrightCE LucidaSans-Typewriter
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips -E wieesgeht.dvi -o wieesgeht.eps
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2009.05.31:1240
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/p{show}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0 N/Ry 0 N/V{}B/RV/v{
/Ry X/Rx X V}B statusdict begin/product where{pop false[(Display)(NeXT)
(LaserWriter 16/600)]{A length product length le{A length product exch 0
exch getinterval eq{pop true exit}if}{pop}ifelse}forall}{false}ifelse
end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{BDot}imagemask
grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat{BDot}
imagemask grestore}}ifelse B/QV{gsave newpath transform round exch round
exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0 rlineto
fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B/M{S p
delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}B/g{0 M}
B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p -3 w}B/n{
p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{0 S
rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
% $Id: pstricks.pro 40 2008-09-04 17:56:41Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 1.06, 2009/01/30
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
% Define the follwing gs-functions if not known, eg when using distiller
%
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if
systemdict /.setblendmode known not {/.setblendmode { pop } def } if
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if
%
/tx@Dict 200 dict def 				% the main PSTricks dictionary
tx@Dict begin
/ADict 25 dict def				% The arrow dictionaray
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 				% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 		% default sin/cos
} def
/Tan { dup sin exch cos Div } def 		% sin(x)/cos(x) x in degrees
/Acos {dup dup mul neg 1 add dup 0 lt {		% arc cos, returns 0 when negative root
  pop pop 0 }{ sqrt exch atan} ifelse } def
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, expects 2 parameter
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def 	% Polar to Cartesian
/Rand { rand 4294967295 div } def		% a real random number
%----------------- hv added 20050516 ---------------
/PiDiv2 1.57079632680 def
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
%/e Euler bind def
%
/RadtoDeg { 180 mul Pi div } bind def 		% convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def 		% viceversa
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
%
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def }
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def
%
/STP { .996264 dup scale } def			% BP/PT scaling
/STV { SDict begin normalscale end STP  } def	% 
%
%%-------------- DG begin patch 15 ---------------%%
%/DashLine { dup 0 gt { /a .5 def PathLength exch div } { pop /a 1 def
%PathLength } ifelse /b ED /x ED /y ED /z y x add def b a .5 sub 2 mul y
%mul sub z Div round z mul a .5 sub 2 mul y mul add b exch Div dup y mul
%/y ED x mul /x ED x 0 gt y 0 gt and { [ y x ] 1 a sub y mul } { [ 1 0 ]
%0 } ifelse setdash stroke } def
/DashLine {
  dup 0 gt { /a .5 def PathLength exch div } { pop /a 1 def PathLength } ifelse
  /b ED /x1 ED /y1 ED /x ED /y ED 
  /z y x add y1 add x1 add def
  /Coef b a .5 sub 2 mul y mul sub z Div round 
    z mul a .5 sub 2 mul y mul add b exch Div def 
  /y y Coef mul def 
  /x x Coef mul def 
  /y1 y1 Coef mul def 
  /x1 x1 Coef mul def
  x1 0 gt y1 0 gt or x 0 gt or y 0 gt and 
    { [ y x y1 x1 ] 1 a sub y mul }
    { [ 1 0 ] 0 } ifelse 
  setdash stroke
} def
%%-------------- DG end patch 15 ---------------%%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
/PenroseFill {%	 on stack: scaling factor
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul}
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
  pop pop 
} def
%
%gsave abs CLW add /a ED a 0 dtransform round exch round exch
%2 copy idtransform exch Atan rotate idtransform pop /a ED .25 .25
%% DG/SR modification begin - Dec. 12, 1997 - Patch 2
%%itransform translate pathbbox /y2 ED a Div ceiling cvi /x2 ED /y1 ED a
%itransform pathbbox /y2 ED a Div ceiling cvi /x2 ED /y1 ED a
%% DG/SR modification end
%Div cvi /x1 ED /y2 y2 y1 sub def clip newpath 2 setlinecap systemdict
%/setstrokeadjust known { true setstrokeadjust } if x2 x1 sub 1 add { x1
%% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
%% a mul y1 moveto 0 y2 rlineto stroke /x1 x1 1 add def } repeat grestore }
%% def
%a mul y1 moveto 0 y2 rlineto stroke /x1 x1 1 add def } repeat grestore
%pop pop } def
%% DG/SR modification end
%
/BeginArrow { 
  ADict begin 			% hold it local, for end see EndArrow
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def
%
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict
%
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def
%
/ArrowD { % the sides are drawn as curves (hv 20071211)
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction
% we use y=w/h^2 * x^2 as equation for the control points
% for the coordinates the arrow is seen from top to bottom
% the bottom (tip) is (0;0)
  w neg h moveto % lower left of >
  w 9 div 4 mul neg h 3 div 2 mul
  w 9 div neg       h 3 div  
  0 0 curveto    % tip of >
  w 9 div        h 3 div  
  w 9 div 4 mul  h 3 div 2 mul
  w h curveto % upper left of >
  w neg Inset neg rlineto % move to x=0 and inset
  gsave fill grestore 
} def 
%
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def
%
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def
%
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def
%
/SD { 0 360 arc fill } def
%
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse 
  /b ED 0 z DS SD b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub moveto } def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
%/NArray { 
%   aload length 2 div dup dup cvi eq not { exch pop } if /n exch
%   cvi def 
%} def
%
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /showpoints ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if
  showpoints { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
%
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def
%
/CheckClosed { dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if } def
/Polygon { NArray n 2 eq { 0 0 /n 3 def } if n 3 lt { n { pop pop }
  repeat } { n 3 gt { CheckClosed } if n 2 mul -2 roll /y0 ED /x0 ED /y1
  ED /x1 ED x1 y1 /x1 x0 x1 add 2 div def /y1 y0 y1 add 2 div def x1 y1
  moveto /n n 2 sub def n { Lineto } repeat x1 y1 x0 y0 6 4 roll Lineto
  Lineto pop pop closepath } ifelse } def
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
% DG modification begin - Jan. 15, 1997
%/Triangle { /mtrx CM def translate rotate /h ED 2 div /w ED dup 0 eq {
%pop } { CLW mul /d ED /h h d w h Atan sin Div sub def /w w d h w Atan 2
%div dup cos exch sin Div mul sub def } ifelse mark 0 d w neg d 0 h w d 0
%d /ArrowA { moveto } def /ArrowB { } def false Line closepath mtrx
%setmatrix } def
%
/Triangle { 
  /mtrx CM def 
  translate 
  rotate /h ED 2 div /w ED 
  dup CLW mul /d ED 
  /h h d w h Atan sin Div sub def 
  /w w d h w Atan 2 div dup cos exch sin Div mul sub def 
  mark 
  0 d w neg d 0 h w d 0 d 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false 
  Line 
  closepath 
  mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
  setmatrix pop 
} def
% DG/SR modification end
%
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def
%
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def
%
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def
%
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
%
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
%
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def
%
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def
%
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore } def
%
/FontDot { 
  DS 2 mul dup 
  matrix scale matrix concatmatrix exch matrix
  rotate matrix concatmatrix exch 
  findfont exch makefont setfont 
} def
%
/Rect { 
  x1 y1 y2 add 2 div moveto 
  x1 y2 lineto 
  x2 y2 lineto 
  x2 y1 lineto
  x1 y1 lineto 
  closepath 
} def
%
/OvalFrame { 
  x1 x2 eq y1 y2 eq or 
    { pop pop x1 y1 moveto x2 y2 L } 
    { y1 y2 sub abs x1 x2 sub abs 2 copy gt 
      { exch pop } { pop } ifelse 
      2 div exch { dup 3 1 roll mul exch } if 
      2 copy lt { pop } { exch pop } ifelse
      /b ED 
      x1 y1 y2 add 2 div moveto 
      x1 y2 x2 y2 b arcto 
      x2 y2 x2 y1 b arcto
      x2 y1 x1 y1 b arcto 
      x1 y1 x1 y2 b arcto 
      16 { pop } repeat 
      closepath 
    } ifelse 
} def
%
/Frame { 
  CLW mul /a ED 
  3 -1 roll 
  2 copy gt { exch } if 
  a sub /y2 ED 
  a add /y1 ED 
  2 copy gt { exch } if 
  a sub /x2 ED 
  a add /x1 ED 
  1 index 0 eq { pop pop Rect } { OvalFrame } ifelse 
} def
%
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def
%
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def
%
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def
%
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def
%
/Parab1 { % 1 end  |  0 SP
  /ySP ED /xSP ED /y1 ED /x1 ED 
  /dx xSP x1 sub 3 div def 
  /dy ySP y1 sub 3 div def 
  newpath x1 y1 moveto xSP y1 lineto xSP ySP lineto 
                       x1 ySP lineto closepath clip 
  currentpoint
  newpath moveto
  xSP dx sub ySP dy add x1 y1 ArrowA
  xSP dx add ySP dy add xSP 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 xSP ySP xSP 2 mul x1 sub y1 ] def 
} def
%
/Grid { 
  newpath 
  /a 4 string def 
  /b ED /c ED /n ED 
  cvi dup 1 lt { pop 1 } if 
  /s ED 
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if
  /dx ED dy div round dy mul 
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def
%    /Helvetica findfont b scalefont setfont 
    /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def }
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
	h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
  % DG/SR modification end
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def
%
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
  mul neg d 
} def
%
/Ellipse { /mtrx CM def T scale 0 0 1 5 3 roll arc mtrx setmatrix } def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % is add or sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
%
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def
%
/RotEnd { 
  /TMatrix [ TMatrix setmatrix ] cvx def 
  /RAngle [ RAngle pop ] cvx def 
} def
%
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/Uput { 
  /a ED 
  add 2 div /h ED 2 
  div /w ED 
  /s a sin def 
  /c a cos def 
  /b s abs c abs 2 copy gt dup 
    /q ED 
    { pop } { exch pop } ifelse def 
  /w1 c b div w mul def 
  /h1 s b div h mul def 
  q { w1 abs w sub dup c mul abs }{ h1 abs h sub dup s mul abs } ifelse 
} def
%
/UUput { 
  /z ED 
  abs /y ED 
  /x ED 
  q { x s div c mul abs y gt }{ x c div s mul abs y gt } ifelse 
    { x x mul y y mul sub z z mul add sqrt z add } 
    { q { x s div } { x c div } ifelse abs 
    } ifelse 
  a PtoC 
  h1 add exch 
  w1 add exch 
} def
%
/BeginOL { 
  dup (all) eq exch TheOL eq or 
    { IfVisible not { Visible /IfVisible true def } if } 
    { IfVisible { Invisible /IfVisible false def } if } ifelse 
} def
%
/InitOL { 
  /OLUnit [ 3000 3000 matrix defaultmatrix dtransform ] cvx def
  /Visible { CP OLUnit idtransform T moveto } def 
  /Invisible { CP OLUnit neg exch neg exch idtransform T moveto } def 
  /BOL { BeginOL } def
  /IfVisible true def 
} def
%
end
%-----------------------------------------------------------------------------%
%
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-algparser.pro 0 0
% $Id: pst-algparser.pro 26 2008-06-14 11:50:02Z herbert $
%%
%% PostScript prologue for PSTricks algorithm parser
%% Version 0.01, 2008/01/01
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%%-----------------------------------------------------------------------------%
%
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez
%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.12
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%
%% E expression, T term, SF signed factor, F factor, P power
%
%% parser
%
%% str
%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower IsEndingFactor { pop exit } if} loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%
%-------------------------------------------------------------------------------%
%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end   %tx@CoreAnalyzerDict
%
%--------------------------------------------------------------------%
%
/tx@Derive 41 dict def tx@Derive begin
%%increase ^^ for each function added
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {%
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan DegtoRad
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { Euler exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
end
%
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
% $Id: pst-dots.pro 11 2008-01-24 13:37:27Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 2.01,  2008/04/18
%%
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%% Modified by Herbert Voss (hv) - 2008/04/17 
%
10 dict dup begin			% hold local
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
  /FontBBox [-571.5 -742.5 571.5 742.5] def
%  /FontBBox [-1000 -1000 1000 1000] def  % See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch /.notdef put} for % fill the array with /.notdef
  Encoding				   % replace with given dot names
    dup (b) 0 get /Bullet put		   % get the numerical position of b in ASCII
%					   % and save /Bullet at this place in Encoding 
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put	% 67
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (f) 0 get /Octogon put		% 2008-04-18 hv
    dup (F) 0 get /BoldOctogon put	% 2008-04-18 hv
    dup (g) 0 get /SolidOctogon put	% 2008-04-18 hv
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put 		% 65
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
CharProcs begin
  /CirclePath {0 0 500 0 360 arc closepath} def
  /Bullet {CirclePath fill} def
  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
  /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto closepath} def
  /SolidTriangle {TrianglePath fill} def
  /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
  /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
  /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto closepath} def
  /SolidSquare {SquarePath fill} def
  /Square {SquarePath .89 .89 scale SquarePath eofill} def
  /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
  /PentagonPath {
    -337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
    0 574.7 lineto -546.6 177.6 lineto closepath
  } def
  /SolidPentagon {PentagonPath fill} def
  /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
  /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
  /HexagonPath {
    0 550 moveto -476 275 lineto -476 -275 lineto
    0 -550 lineto 476 -275 lineto 476 275 lineto closepath
  } def
  /SolidHexagon {HexagonPath fill} def
  /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
  /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
%					2008-04-18 hv
  /OctogonPath {
    228 550 moveto 7 { -456 0 rlineto 45 rotate } repeat 
    closepath
  } def 
  /SolidOctogon { OctogonPath fill                             } def
  /Octogon {      OctogonPath .89 .89 scale OctogonPath eofill } def
  /BoldOctogon {  OctogonPath .79 .79 scale OctogonPath eofill } def
%
  /AsteriskPath {
    20 0 moveto 10 250 180 500 0 500 curveto
    -180 500 -10 250 -20 0 curveto closepath
  } def
  /Asterisk {
    AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath fill
  } def
%
  /Basterp {50 250 220 500 0 500 curveto -220 500 -50 250 -50 30 cos 100 mul curveto} def
  /BoldAsteriskPath {
    50 30 cos 100 mul moveto  Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp closepath
  } def
  /BoldAsterisk {BoldAsteriskPath fill} def
  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
  /CrossPath {
    40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
    -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
    40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath
  } def
  /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
    -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
    80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath
  } def
  /Add {CrossPath fill} def
  /Mul {45 rotate CrossPath fill} def
  /BoldAdd {BoldCrossPath fill} def
  /BoldMul {45 rotate BoldCrossPath fill} def
  /Oplus {CirclePath .9 .9 scale CirclePath eofill .775 .775 scale CrossPath fill } def 
  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
  /BOplus {CirclePath .8 .8 scale CirclePath eofill .775 .775 scale BoldCrossPath fill} def 
  /Otimes {CirclePath .9 .9 scale CirclePath eofill 45 rotate .775 .775 scale CrossPath fill} def 
  /BOtimes {CirclePath .8 .8 scale CirclePath eofill 45 rotate .775 .775 scale BoldCrossPath fill } def 
  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
  /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto closepath} def
  /Bar {BarPath fill} def
  /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto closepath} def
  /BoldBar {BoldBarPath fill} def
  /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 428.5 0 lineto closepath} def
  /SolidDiamond {DiamondPath fill} def
  /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
  /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
  /.notdef { } def
end
%
/BuildGlyph {
  exch
  begin 		
%  Metrics 1 index get exec 0
    0 0
%      BBoxes 3 index get exec
    -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
    setcachedevice
    CharProcs begin load exec end
  end
} def
%
/BuildChar {
  1 index /Encoding get exch get
  1 index /BuildGlyph get exec
} bind def

end
/PSTricksDotFont exch definefont pop

%% end

%%EndProcSet
%%BeginProcSet: xcolor.pro 0 0
%!
%%
%% This is file `xcolor.pro',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% xcolor.dtx  (with options: `dvips')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from xcolor.pro.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file xcolor.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%% xcolor.pro (PostScript/dvips header file)
%%  [2007/01/21 v2.11 LaTeX color extensions (UK)]
%%
%% ----------------------------------------------------------------
%% Copyright (C) 2003-2007 by Dr. Uwe Kern <xcolor at ukern dot de>
%% ----------------------------------------------------------------
%%
userdict begin
/setcmycolor{0 setcmykcolor}def
/XCbd{bind def}bind def
/XCed{exch def}XCbd
/XCdef{exch dup TeXDict exch known{pop pop}{XCed}ifelse}XCbd
/XCsetcolor{cvx counttomark array astore cvx exch pop XCdef}XCbd
/XCcmy{mark exch exec/setcmycolor XCsetcolor}XCbd
/XCcmyk{mark exch exec/setcmykcolor XCsetcolor}XCbd
/XCgray{mark exch exec/setgray XCsetcolor}XCbd
/XChsb{mark exch exec/sethsbcolor XCsetcolor}XCbd
/XCrgb{mark exch exec/setrgbcolor XCsetcolor}XCbd
/XCfixnormalscale{/normalscale{Resolution 72 div VResolution 72 div neg
  scale magscale{DVImag dup scale}if}def}def
/XC!b{save XCfixnormalscale}XCbd
/XC!e{restore}XCbd
/XCsp2bp{1 65781.76 div dup scale}XCbd
/XCsetline
 {setlinewidth [] 0 setdash 2 setlinecap 0 setlinejoin 4 setmiterlimit}XCbd
/XCboxframe{/d XCed/h XCed/w XCed/l XCed w 0 gt{h d neg gt{l 0 gt
 {XCsp2bp l XCsetline
  l 2 div dup translate
  0 d neg w l sub h l sub d add rectstroke}if}if}if}XCbd
/XCcolorblock{/d XCed/h XCed/w XCed w 0 gt{h d neg gt
 {XCsp2bp 0 XCsetline
  0 d neg w h d add rectfill}if}if}XCbd
end
%% End of file `xcolor.pro'.

%%EndProcSet
%%BeginProcSet: wieesgeht.xcp 0 0
%!
TeXDict begin
/XC@red{0 1 1 0}XCcmyk
/XC@green{1 0 1 0}XCcmyk
/XC@blue{1 1 0 0}XCcmyk
/XC@brown{0 0.25 0.5 0.25}XCcmyk
/XC@lime{0.25 0 1 0}XCcmyk
/XC@orange{0 0.5 1 0}XCcmyk
/XC@pink{0 0.25 0.25 0}XCcmyk
/XC@purple{0 0.75 0.5 0.25}XCcmyk
/XC@teal{0.5 0 0 0.5}XCcmyk
/XC@violet{0 0.5 0 0.5}XCcmyk
/XC@cyan{1 0 0 0}XCcmyk
/XC@magenta{0 1 0 0}XCcmyk
/XC@yellow{0 0 1 0}XCcmyk
/XC@olive{0 0 1 0.5}XCcmyk
/XC@black{0 0 0 1}XCcmyk
/XC@darkgray{0 0 0 0.75}XCcmyk
/XC@gray{0 0 0 0.5}XCcmyk
/XC@lightgray{0 0 0 0.25}XCcmyk
/XC@white{0 0 0 0}XCcmyk
/GreenYellow{0.15 0 0.69 0}XCcmyk
/Yellow{0 0 1 0}XCcmyk
/Goldenrod{0 0.1 0.84 0}XCcmyk
/Dandelion{0 0.29 0.84 0}XCcmyk
/Apricot{0 0.32 0.52 0}XCcmyk
/Peach{0 0.5 0.7 0}XCcmyk
/Melon{0 0.46 0.5 0}XCcmyk
/YellowOrange{0 0.42 1 0}XCcmyk
/Orange{0 0.61 0.87 0}XCcmyk
/BurntOrange{0 0.51 1 0}XCcmyk
/Bittersweet{0 0.75 1 0.24}XCcmyk
/RedOrange{0 0.77 0.87 0}XCcmyk
/Mahogany{0 0.85 0.87 0.35}XCcmyk
/Maroon{0 0.87 0.68 0.32}XCcmyk
/BrickRed{0 0.89 0.94 0.28}XCcmyk
/Red{0 1 1 0}XCcmyk
/OrangeRed{0 1 0.5 0}XCcmyk
/RubineRed{0 1 0.13 0}XCcmyk
/WildStrawberry{0 0.96 0.39 0}XCcmyk
/Salmon{0 0.53 0.38 0}XCcmyk
/CarnationPink{0 0.63 0 0}XCcmyk
/Magenta{0 1 0 0}XCcmyk
/VioletRed{0 0.81 0 0}XCcmyk
/Rhodamine{0 0.82 0 0}XCcmyk
/Mulberry{0.34 0.9 0 0.02}XCcmyk
/RedViolet{0.07 0.9 0 0.34}XCcmyk
/Fuchsia{0.47 0.91 0 0.08}XCcmyk
/Lavender{0 0.48 0 0}XCcmyk
/Thistle{0.12 0.59 0 0}XCcmyk
/Orchid{0.32 0.64 0 0}XCcmyk
/DarkOrchid{0.4 0.8 0.2 0}XCcmyk
/Purple{0.45 0.86 0 0}XCcmyk
/Plum{0.5 1 0 0}XCcmyk
/Violet{0.79 0.88 0 0}XCcmyk
/RoyalPurple{0.75 0.9 0 0}XCcmyk
/BlueViolet{0.86 0.91 0 0.04}XCcmyk
/Periwinkle{0.57 0.55 0 0}XCcmyk
/CadetBlue{0.62 0.57 0.23 0}XCcmyk
/CornflowerBlue{0.65 0.13 0 0}XCcmyk
/MidnightBlue{0.98 0.13 0 0.43}XCcmyk
/NavyBlue{0.94 0.54 0 0}XCcmyk
/RoyalBlue{1 0.5 0 0}XCcmyk
/Blue{1 1 0 0}XCcmyk
/Cerulean{0.94 0.11 0 0}XCcmyk
/Cyan{1 0 0 0}XCcmyk
/ProcessBlue{0.96 0 0 0}XCcmyk
/SkyBlue{0.62 0 0.12 0}XCcmyk
/Turquoise{0.85 0 0.2 0}XCcmyk
/TealBlue{0.86 0 0.34 0.02}XCcmyk
/Aquamarine{0.82 0 0.3 0}XCcmyk
/BlueGreen{0.85 0 0.33 0}XCcmyk
/Emerald{1 0 0.5 0}XCcmyk
/JungleGreen{0.99 0 0.52 0}XCcmyk
/SeaGreen{0.69 0 0.5 0}XCcmyk
/Green{1 0 1 0}XCcmyk
/ForestGreen{0.91 0 0.88 0.12}XCcmyk
/PineGreen{0.92 0 0.59 0.25}XCcmyk
/LimeGreen{0.5 0 1 0}XCcmyk
/YellowGreen{0.44 0 0.74 0}XCcmyk
/SpringGreen{0.26 0 0.76 0}XCcmyk
/OliveGreen{0.64 0 0.95 0.4}XCcmyk
/RawSienna{0 0.72 1 0.45}XCcmyk
/Sepia{0 0.83 1 0.7}XCcmyk
/Brown{0 0.81 1 0.6}XCcmyk
/Tan{0.14 0.42 0.56 0}XCcmyk
/Gray{0 0 0 0.5}XCcmyk
/Black{0 0 0 1}XCcmyk
/White{0 0 0 0}XCcmyk
/XC@AliceBlue{0.06 0.028 0 0}XCcmyk
/XC@AntiqueWhite{0 0.06 0.136 0.02}XCcmyk
/XC@Aqua{1 0 0 0}XCcmyk
/XC@Aquamarine{0.502 0 0.17 0}XCcmyk
/XC@Azure{0.06 0 0 0}XCcmyk
/XC@Beige{0 0 0.096 0.04}XCcmyk
/XC@Bisque{0 0.106 0.23 0}XCcmyk
/XC@Black{0 0 0 1}XCcmyk
/XC@BlanchedAlmond{0 0.08 0.196 0}XCcmyk
/XC@Blue{1 1 0 0}XCcmyk
/XC@BlueViolet{0.348 0.718 0 0.112}XCcmyk
/XC@Brown{0 0.483 0.483 0.352}XCcmyk
/XC@BurlyWood{0 0.15 0.34 0.13}XCcmyk
/XC@CadetBlue{0.256 0.008 0 0.372}XCcmyk
/XC@Chartreuse{0.502 0 1 0}XCcmyk
/XC@Chocolate{0 0.414 0.708 0.176}XCcmyk
/XC@Coral{0 0.502 0.688 0}XCcmyk
/XC@CornflowerBlue{0.538 0.345 0 0.07}XCcmyk
/XC@Cornsilk{0 0.028 0.136 0}XCcmyk
/XC@Crimson{0 0.784 0.629 0.136}XCcmyk
/XC@Cyan{1 0 0 0}XCcmyk
/XC@DarkBlue{0.545 0.545 0 0.455}XCcmyk
/XC@DarkCyan{0.545 0 0 0.455}XCcmyk
/XC@DarkGoldenrod{0 0.195 0.676 0.28}XCcmyk
/XC@DarkGray{0 0 0 0.336}XCcmyk
/XC@DarkGreen{0.392 0 0.392 0.608}XCcmyk
/XC@DarkGrey{0 0 0 0.336}XCcmyk
/XC@DarkKhaki{0 0.024 0.32 0.26}XCcmyk
/XC@DarkMagenta{0 0.545 0 0.455}XCcmyk
/XC@DarkOliveGreen{0.088 0 0.235 0.58}XCcmyk
/XC@DarkOrange{0 0.45 1 0}XCcmyk
/XC@DarkOrchid{0.2 0.604 0 0.2}XCcmyk
/XC@DarkRed{0 0.545 0.545 0.455}XCcmyk
/XC@DarkSalmon{0 0.322 0.432 0.088}XCcmyk
/XC@DarkSeaGreen{0.176 0 0.176 0.264}XCcmyk
/XC@DarkSlateBlue{0.261 0.305 0 0.455}XCcmyk
/XC@DarkSlateGray{0.125 0 0 0.69}XCcmyk
/XC@DarkSlateGrey{0.125 0 0 0.69}XCcmyk
/XC@DarkTurquoise{0.82 0.012 0 0.18}XCcmyk
/XC@DarkViolet{0.248 0.828 0 0.172}XCcmyk
/XC@DeepPink{0 0.92 0.424 0}XCcmyk
/XC@DeepSkyBlue{1 0.25 0 0}XCcmyk
/XC@DimGray{0 0 0 0.59}XCcmyk
/XC@DimGrey{0 0 0 0.59}XCcmyk
/XC@DodgerBlue{0.884 0.435 0 0}XCcmyk
/XC@FireBrick{0 0.566 0.566 0.302}XCcmyk
/XC@FloralWhite{0 0.02 0.06 0}XCcmyk
/XC@ForestGreen{0.413 0 0.413 0.455}XCcmyk
/XC@Fuchsia{0 1 0 0}XCcmyk
/XC@Gainsboro{0 0 0 0.136}XCcmyk
/XC@GhostWhite{0.028 0.028 0 0}XCcmyk
/XC@Gold{0 0.156 1 0}XCcmyk
/XC@Goldenrod{0 0.207 0.73 0.145}XCcmyk
/XC@Gray{0 0 0 0.5}XCcmyk
/XC@Green{0.5 0 0.5 0.5}XCcmyk
/XC@GreenYellow{0.32 0 0.815 0}XCcmyk
/XC@Grey{0 0 0 0.5}XCcmyk
/XC@Honeydew{0.06 0 0.06 0}XCcmyk
/XC@HotPink{0 0.59 0.295 0}XCcmyk
/XC@IndianRed{0 0.444 0.444 0.196}XCcmyk
/XC@Indigo{0.216 0.51 0 0.49}XCcmyk
/XC@Ivory{0 0 0.06 0}XCcmyk
/XC@Khaki{0 0.04 0.39 0.06}XCcmyk
/XC@Lavender{0.08 0.08 0 0.02}XCcmyk
/XC@LavenderBlush{0 0.06 0.04 0}XCcmyk
/XC@LawnGreen{0.502 0 0.99 0.01}XCcmyk
/XC@LemonChiffon{0 0.02 0.196 0}XCcmyk
/XC@LightBlue{0.22 0.052 0 0.1}XCcmyk
/XC@LightCoral{0 0.44 0.44 0.06}XCcmyk
/XC@LightCyan{0.12 0 0 0}XCcmyk
/XC@LightGoldenrod{0 0.066 0.423 0.067}XCcmyk
/XC@LightGoldenrodYellow{0 0 0.156 0.02}XCcmyk
/XC@LightGray{0 0 0 0.172}XCcmyk
/XC@LightGreen{0.367 0 0.367 0.068}XCcmyk
/XC@LightGrey{0 0 0 0.172}XCcmyk
/XC@LightPink{0 0.288 0.244 0}XCcmyk
/XC@LightSalmon{0 0.372 0.52 0}XCcmyk
/XC@LightSeaGreen{0.573 0 0.03 0.302}XCcmyk
/XC@LightSkyBlue{0.45 0.172 0 0.02}XCcmyk
/XC@LightSlateBlue{0.482 0.56 0 0}XCcmyk
/XC@LightSlateGray{0.132 0.068 0 0.4}XCcmyk
/XC@LightSlateGrey{0.132 0.068 0 0.4}XCcmyk
/XC@LightSteelBlue{0.18 0.1 0 0.13}XCcmyk
/XC@LightYellow{0 0 0.12 0}XCcmyk
/XC@Lime{1 0 1 0}XCcmyk
/XC@LimeGreen{0.608 0 0.608 0.196}XCcmyk
/XC@Linen{0 0.04 0.08 0.02}XCcmyk
/XC@Magenta{0 1 0 0}XCcmyk
/XC@Maroon{0 0.5 0.5 0.5}XCcmyk
/XC@MediumAquamarine{0.404 0 0.136 0.196}XCcmyk
/XC@MediumBlue{0.804 0.804 0 0.196}XCcmyk
/XC@MediumOrchid{0.098 0.496 0 0.172}XCcmyk
/XC@MediumPurple{0.284 0.42 0 0.14}XCcmyk
/XC@MediumSeaGreen{0.465 0 0.256 0.3}XCcmyk
/XC@MediumSlateBlue{0.448 0.524 0 0.068}XCcmyk
/XC@MediumSpringGreen{0.98 0 0.376 0.02}XCcmyk
/XC@MediumTurquoise{0.536 0 0.02 0.18}XCcmyk
/XC@MediumVioletRed{0 0.696 0.26 0.22}XCcmyk
/XC@MidnightBlue{0.342 0.342 0 0.56}XCcmyk
/XC@MintCream{0.04 0 0.02 0}XCcmyk
/XC@MistyRose{0 0.106 0.116 0}XCcmyk
/XC@Moccasin{0 0.106 0.29 0}XCcmyk
/XC@NavajoWhite{0 0.13 0.32 0}XCcmyk
/XC@Navy{0.5 0.5 0 0.5}XCcmyk
/XC@NavyBlue{0.5 0.5 0 0.5}XCcmyk
/XC@OldLace{0 0.032 0.092 0.008}XCcmyk
/XC@Olive{0 0 0.5 0.5}XCcmyk
/XC@OliveDrab{0.136 0 0.42 0.444}XCcmyk
/XC@Orange{0 0.352 1 0}XCcmyk
/XC@OrangeRed{0 0.73 1 0}XCcmyk
/XC@Orchid{0 0.415 0.015 0.145}XCcmyk
/XC@PaleGoldenrod{0 0.022 0.264 0.068}XCcmyk
/XC@PaleGreen{0.389 0 0.389 0.015}XCcmyk
/XC@PaleTurquoise{0.244 0 0 0.068}XCcmyk
/XC@PaleVioletRed{0 0.42 0.284 0.14}XCcmyk
/XC@PapayaWhip{0 0.064 0.165 0}XCcmyk
/XC@PeachPuff{0 0.145 0.275 0}XCcmyk
/XC@Peru{0 0.284 0.556 0.196}XCcmyk
/XC@Pink{0 0.248 0.204 0}XCcmyk
/XC@Plum{0 0.24 0 0.132}XCcmyk
/XC@PowderBlue{0.21 0.02 0 0.1}XCcmyk
/XC@Purple{0 0.5 0 0.5}XCcmyk
/XC@Red{0 1 1 0}XCcmyk
/XC@RosyBrown{0 0.176 0.176 0.264}XCcmyk
/XC@RoyalBlue{0.629 0.474 0 0.116}XCcmyk
/XC@SaddleBrown{0 0.275 0.47 0.455}XCcmyk
/XC@Salmon{0 0.48 0.532 0.02}XCcmyk
/XC@SandyBrown{0 0.312 0.58 0.044}XCcmyk
/XC@SeaGreen{0.365 0 0.205 0.455}XCcmyk
/XC@Seashell{0 0.04 0.068 0}XCcmyk
/XC@Sienna{0 0.308 0.452 0.372}XCcmyk
/XC@Silver{0 0 0 0.248}XCcmyk
/XC@SkyBlue{0.39 0.112 0 0.08}XCcmyk
/XC@SlateBlue{0.389 0.452 0 0.196}XCcmyk
/XC@SlateGray{0.125 0.065 0 0.435}XCcmyk
/XC@SlateGrey{0.125 0.065 0 0.435}XCcmyk
/XC@Snow{0 0.02 0.02 0}XCcmyk
/XC@SpringGreen{1 0 0.502 0}XCcmyk
/XC@SteelBlue{0.43 0.195 0 0.295}XCcmyk
/XC@Tan{0 0.119 0.274 0.176}XCcmyk
/XC@Teal{0.5 0 0 0.5}XCcmyk
/XC@Thistle{0 0.098 0 0.152}XCcmyk
/XC@Tomato{0 0.61 0.72 0}XCcmyk
/XC@Turquoise{0.63 0 0.065 0.12}XCcmyk
/XC@Violet{0 0.422 0 0.068}XCcmyk
/XC@VioletRed{0 0.691 0.251 0.184}XCcmyk
/XC@Wheat{0 0.09 0.26 0.04}XCcmyk
/XC@White{0 0 0 0}XCcmyk
/XC@WhiteSmoke{0 0 0 0.04}XCcmyk
/XC@Yellow{0 0 1 0}XCcmyk
/XC@YellowGreen{0.2 0 0.608 0.196}XCcmyk
/XC@gradbegin{1 0 0 0}XCcmyk
/XC@gradend{0.95 0.85 0 0.05}XCcmyk
/XC@black{0 0 0 1}XCcmyk
/XC@darkgray{0 0 0 0.75}XCcmyk
/XC@gray{0 0 0 0.5}XCcmyk
/XC@lightgray{0 0 0 0.25}XCcmyk
/XC@white{0 0 0 0}XCcmyk
/XC@red{0 1 1 0}XCcmyk
/XC@green{1 0 1 0}XCcmyk
/XC@blue{1 1 0 0}XCcmyk
/XC@yellow{0 0 1 0}XCcmyk
/XC@cyan{1 0 0 0}XCcmyk
/XC@magenta{0 1 0 0}XCcmyk
end

%%EndProcSet
%%BeginProcSet: pst-node.pro 0 0
% $Id: pst-node.pro 40 2008-09-04 17:56:41Z herbert $
%%
%% PostScript prologue for pst-node.tex.
%% Version 1.02, 2009/01/30.
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
/tx@NodeDict 400 dict def tx@NodeDict begin
tx@Dict begin 			% from main pstricks dict
 /T /translate load def 
end
/NewNode { % on stack: { x y } boolean N@name type InitXnode 
  gsave 
  /next ED 			% { x y } boolean N@name type  
  dict dup 			% { x y } boolean N@name dict dict
  3 1 roll def 			% { x y } boolean dict N@name dict def
  exch { dup 3 1 roll def } if  % { x y } dict boolean
  begin 			% { x y } dict begin
  tx@Dict begin 
    STV CP T exec 		% set scaling
  end 
  /NodeMtrx CM def 		% save CM
  next 				% InitXNode
  end
  grestore 
} def
%
/InitPnode { 
  /Y ED /X ED 
  /NodePos { NodeSep Cos mul NodeSep Sin mul } def
} def
%
/InitCnode { 
  /r ED /Y ED /X ED 
  /NodePos { NodeSep r add dup Cos mul exch Sin mul } def 
} def
%
/GetRnodePos { 
  Cos 0 gt { /dx r NodeSep add def } { /dx l NodeSep sub def } ifelse 
  Sin 0 gt { /dy u NodeSep add def } { /dy d NodeSep sub def } ifelse 
  dx Sin mul abs dy 
  Cos mul abs gt { dy Cos mul Sin div dy } { dx dup Sin mul Cos Div } ifelse 
} def
%
/InitRnode { 
  /Y ED /X ED X sub /r ED /l X neg def Y add neg /d ED Y sub /u ED 
  /NodePos { GetRnodePos } def 
} def
%
/DiaNodePos { 
  w h mul w Sin mul abs h Cos mul abs add Div NodeSep add dup
  Cos mul exch Sin mul 
} def
%
/TriNodePos { 
  Sin s lt 
    { d NodeSep sub dup Cos mul Sin Div exch } 
    { w h mul w Sin mul h Cos abs mul add Div 
      NodeSep add dup Cos mul exch Sin mul 
    } ifelse 
} def
%
/InitTriNode { 
  sub 2 div exch 
  2 div exch 
  2 copy T 
  2 copy 4 index index /d ED 
  pop pop pop pop 
  -90 mul rotate 
  /NodeMtrx CM def 
  /X 0 def /Y 0 def 
  d sub abs neg /d ED 
  d add /h ED 
  2 div h mul h d sub Div /w ED 
  /s d w Atan sin def 
  /NodePos { TriNodePos } def 
} def
%
/OvalNodePos { 
  /ww w NodeSep add def 
  /hh h NodeSep add def 
  Sin ww mul Cos hh mul Atan dup cos ww mul exch sin hh mul 
} def
%
/GetCenter { begin X Y NodeMtrx transform CM itransform end } def
%
/XYPos { 
  dup sin exch cos Do 
  /Cos ED /Sin ED /Dist ED 
  Cos 0 gt 
    { Dist Dist Sin mul Cos div }
    { Cos 0 lt 
      { Dist neg Dist Sin mul Cos div neg }
      { 0 Dist Sin mul } ifelse 
    } ifelse 
  Do 
} def
%
/GetEdge { 
  dup 0 eq 
    { pop begin 1 0 NodeMtrx dtransform 
      CM idtransform 
      exch atan sub 
      dup 
      sin /Sin ED 
      cos /Cos ED 
      /NodeSep ED 
      NodePos NodeMtrx dtransform CM idtransform end }
    { 1 eq {{exch}} {{}} ifelse /Do ED pop XYPos } ifelse 
} def
%
/AddOffset { 
  1 index 0 eq 
    { pop pop } 
    { 2 copy 5 2 roll cos mul add 4 1 roll sin mul sub exch } ifelse 
} def
%
/GetEdgeA { 
  NodeSepA AngleA NodeA NodeSepTypeA GetEdge 
  OffsetA AngleA AddOffset 
  yA add /yA1 ED 
  xA add /xA1 ED 
} def
%
/GetEdgeB { 
  NodeSepB AngleB NodeB NodeSepTypeB GetEdge 
  OffsetB AngleB AddOffset 
  yB add /yB1 ED 
  xB add /xB1 ED 
} def
%
/GetArmA { 
  ArmTypeA 0 eq 
    { /xA2 ArmA AngleA cos mul xA1 add def 
      /yA2 ArmA AngleA sin mul yA1 add def } 
    { ArmTypeA 1 eq {{exch}} {{}} ifelse 
      /Do ED 
      ArmA AngleA XYPos OffsetA AngleA AddOffset 
      yA add /yA2 ED 
      xA add /xA2 ED } ifelse 
} def
%
/GetArmB { 
  ArmTypeB 0 eq 
    { /xB2 ArmB AngleB cos mul xB1 add def 
      /yB2 ArmB AngleB sin mul yB1 add def } 
    { ArmTypeB 1 eq {{exch}} {{}} ifelse 
      /Do ED
      ArmB AngleB XYPos OffsetB AngleB AddOffset 
      yB add /yB2 ED 
      xB add /xB2 ED } ifelse 
} def
%
/InitNC { 
  /b ED /a ED % second and first node
  /NodeSepTypeB ED /NodeSepTypeA ED 
  /NodeSepB ED /NodeSepA ED 
  /OffsetB ED /OffsetA ED 
  tx@NodeDict a known tx@NodeDict b known and dup { 
    /NodeA a load def 
    /NodeB b load def 
    NodeA GetCenter /yA ED /xA ED 
    NodeB GetCenter /yB ED /xB ED } if 
} def
%
/LPutLine { 
  4 copy 
  3 -1 roll sub neg 3 1 roll sub Atan /NAngle ED 
  1 t sub mul 
  3 1 roll 1 t sub mul 
  4 1 roll t mul add /Y ED 
  t mul add /X ED 
} def
%
/LPutLines { 
  mark LPutVar counttomark 2 div 1 sub /n ED 
%  t floor dup n gt 
  t floor dup n ge 		% to allow npos<= hv 2008-08-14
  { pop n 1 sub /t 1 def } { dup t sub neg /t ED } ifelse 
  cvi 2 mul { pop } repeat 
  LPutLine 
  cleartomark 
} def
%
/BezierMidpoint { /y3 ED /x3 ED /y2 ED /x2 ED /y1 ED /x1 ED /y0 ED /x0 ED
/t ED /cx x1 x0 sub 3 mul def /cy y1 y0 sub 3 mul def /bx x2 x1 sub 3
mul cx sub def /by y2 y1 sub 3 mul cy sub def /ax x3 x0 sub cx sub bx
sub def /ay y3 y0 sub cy sub by sub def ax t 3 exp mul bx t t mul mul
add cx t mul add x0 add ay t 3 exp mul by t t mul mul add cy t mul add
y0 add 3 ay t t mul mul mul 2 by t mul mul add cy add 3 ax t t mul mul
mul 2 bx t mul mul add cx add atan /NAngle ED /Y ED /X ED } def
/HPosBegin { yB yA ge { /t 1 t sub def } if /Y yB yA sub t mul yA add def
} def
/HPosEnd { /X Y yyA sub yyB yyA sub Div xxB xxA sub mul xxA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/HPutLine { HPosBegin /yyA ED /xxA ED /yyB ED /xxB ED HPosEnd  } def
/HPutLines { HPosBegin yB yA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { dup Y check { exit
} { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark HPosEnd 
} def
/VPosBegin { xB xA lt { /t 1 t sub def } if /X xB xA sub t mul xA add def
} def
/VPosEnd { /Y X xxA sub xxB xxA sub Div yyB yyA sub mul yyA add def
/NAngle yyB yyA sub xxB xxA sub Atan def } def
/VPutLine { VPosBegin /yyA ED /xxA ED /yyB ED /xxB ED VPosEnd  } def
/VPutLines { VPosBegin xB xA ge { /check { le } def } { /check { ge } def
} ifelse /xxA xA def /yyA yA def mark xB yB LPutVar { 1 index X check {
exit } { /yyA ED /xxA ED } ifelse } loop /yyB ED /xxB ED cleartomark
VPosEnd  } def
/HPutCurve { gsave newpath /SaveLPutVar /LPutVar load def LPutVar 8 -2
roll moveto curveto flattenpath /LPutVar [ {} {} {} {} pathforall ] cvx
def grestore exec /LPutVar /SaveLPutVar load def } def
/NCCoor { /AngleA yB yA sub xB xA sub Atan def /AngleB AngleA 180 add def
GetEdgeA GetEdgeB /LPutVar [ xB1 yB1 xA1 yA1 ] cvx def /LPutPos {
LPutVar LPutLine } def /HPutPos { LPutVar HPutLine } def /VPutPos {
LPutVar VPutLine } def LPutVar } def
/NCLine { NCCoor tx@Dict begin ArrowA CP 4 2 roll ArrowB lineto pop pop
end } def
/NCLines { false NArray n 0 eq { NCLine } { 2 copy yA sub exch xA sub
Atan /AngleA ED n 2 mul dup index exch index yB sub exch xB sub Atan
/AngleB ED GetEdgeA GetEdgeB /LPutVar [ xB1 yB1 n 2 mul 4 add 4 roll xA1
yA1 ] cvx def mark LPutVar tx@Dict begin false Line end /LPutPos {
LPutLines } def /HPutPos { HPutLines } def /VPutPos { VPutLines } def }
ifelse } def
/NCCurve { GetEdgeA GetEdgeB xA1 xB1 sub yA1 yB1 sub Pyth 2 div dup 3 -1
roll mul /ArmA ED mul /ArmB ED /ArmTypeA 0 def /ArmTypeB 0 def GetArmA
GetArmB xA2 yA2 xA1 yA1 tx@Dict begin ArrowA end xB2 yB2 xB1 yB1 tx@Dict
begin ArrowB end curveto /LPutVar [ xA1 yA1 xA2 yA2 xB2 yB2 xB1 yB1 ]
cvx def /LPutPos { t LPutVar BezierMidpoint } def /HPutPos { { HPutLines
} HPutCurve } def /VPutPos { { VPutLines } HPutCurve } def } def
%
/NCAngles { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform pop 
  xB2 yB2 mtrx transform exch pop 
  mtrx itransform 
  /y0 ED /x0 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def } def
%
/NCAngle { 
  GetEdgeA GetEdgeB GetArmB 
  /mtrx AngleA matrix rotate def 
  xB2 yB2 mtrx itransform pop xA1 yA1 mtrx itransform exch pop mtrx transform
  /y0 ED /x0 ED 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 x0 y0 xA1 yA1
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 x0 y0 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCBar { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def
  xA2 yA2 mtrx itransform pop 
  xB2 yB2 mtrx itransform pop 
  sub dup 0 mtrx transform 
  3 -1 roll 0 gt 
    { /yB2 exch yB2 add def /xB2 exch xB2 add def }
    { /yA2 exch neg yA2 add def /xA2 exch neg xA2 add def } ifelse 
  mark 
  ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCDiag { 
  GetEdgeA GetEdgeB GetArmA GetArmB mark 
  ArmB 0 ne { xB1 yB1 } if
  xB2 yB2 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end
  /LPutVar [ xB1 yB1 xB2 yB2 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCDiagg { 
  GetEdgeA GetArmA 
  yB yA2 sub xB xA2 sub Atan 180 add /AngleB ED
  GetEdgeB 
  mark 
  xB1 yB1 xA2 yA2 
  ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
/NCLoop { 
  GetEdgeA GetEdgeB GetArmA GetArmB 
  /mtrx AngleA matrix rotate def 
  xA2 yA2 mtrx transform loopsize add /yA3 ED /xA3 ED 
  /xB3 xB2 yB2 mtrx transform pop def 
  xB3 yA3 mtrx itransform /yB3 ED /xB3 ED 
  xA3 yA3 mtrx itransform /yA3 ED /xA3 ED 
  mark ArmB 0 ne { xB1 yB1 } if 
  xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 ArmA 0 ne { xA1 yA1 } if 
  tx@Dict begin false Line end 
  /LPutVar [ xB1 yB1 xB2 yB2 xB3 yB3 xA3 yA3 xA2 yA2 xA1 yA1 ] cvx def 
  /LPutPos { LPutLines } def 
  /HPutPos { HPutLines } def 
  /VPutPos { VPutLines } def 
} def
%
% DG/SR modification begin - May 9, 1997 - Patch 1
%/NCCircle { 0 0 NodesepA nodeA \tx@GetEdge pop xA sub 2 div dup 2 exp r
%r mul sub abs sqrt atan 2 mul /a ED r AngleA 90 add PtoC yA add exch xA add
%exch 2 copy /LPutVar [ 4 2 roll r AngleA ] cvx def /LPutPos { LPutVar t 360
%mul add dup 5 1 roll 90 sub \tx@PtoC 3 -1 roll add /Y ED add /X ED /NAngle ED
%
/NCCircle { 
  NodeSepA 0 NodeA 0 GetEdge pop 
  2 div dup 2 exp r r mul sub abs sqrt 
  atan 2 mul /a ED 
  r AngleA 90 add PtoC yA add exch xA add 
  exch 2 copy 
  /LPutVar [ 4 2 roll r AngleA ] cvx def 
  /LPutPos { 
    LPutVar t 360 mul add dup 5 1 roll 90 sub PtoC 
    3 -1 roll add 
    /Y ED add /X ED /NAngle ED
% DG/SR modification end
  } def 
  /HPutPos { LPutPos } def 
  /VPutPos { LPutPos } def 
  r AngleA 90 sub a add AngleA 270 add a sub 
  tx@Dict begin 
  /angleB ED /angleA ED /r ED 
  /c 57.2957 r Div def 
  /y ED /x ED 
} def
%
/NCBox { /d ED /h ED /AngleB yB yA sub xB xA sub Atan def /AngleA AngleB
180 add def GetEdgeA GetEdgeB /dx d AngleB sin mul def /dy d AngleB cos
mul neg def /hx h AngleB sin mul neg def /hy h AngleB cos mul def
/LPutVar [ xA1 hx add yA1 hy add xB1 hx add yB1 hy add xB1 dx add yB1 dy
add xA1 dx add yA1 dy add ] cvx def /LPutPos { LPutLines } def /HPutPos
{ xB yB xA yA LPutLine } def /VPutPos { HPutPos } def mark LPutVar
tx@Dict begin false Polygon end } def
/NCArcBox { /l ED neg /d ED /h ED /a ED /AngleA yB yA sub xB xA sub Atan
def /AngleB AngleA 180 add def /tA AngleA a sub 90 add def /tB tA a 2
mul add def /r xB xA sub tA cos tB cos sub Div dup 0 eq { pop 1 } if def
/x0 xA r tA cos mul add def /y0 yA r tA sin mul add def /c 57.2958 r div
def /AngleA AngleA a sub 180 add def /AngleB AngleB a add 180 add def
GetEdgeA GetEdgeB /AngleA tA 180 add yA yA1 sub xA xA1 sub Pyth c mul
sub def /AngleB tB 180 add yB yB1 sub xB xB1 sub Pyth c mul add def l 0
eq { x0 y0 r h add AngleA AngleB arc x0 y0 r d add AngleB AngleA arcn }
{ x0 y0 translate /tA AngleA l c mul add def /tB AngleB l c mul sub def
0 0 r h add tA tB arc r h add AngleB PtoC r d add AngleB PtoC 2 copy 6 2
roll l arcto 4 { pop } repeat r d add tB PtoC l arcto 4 { pop } repeat 0
0 r d add tB tA arcn r d add AngleA PtoC r h add AngleA PtoC 2 copy 6 2
roll l arcto 4 { pop } repeat r h add tA PtoC l arcto 4 { pop } repeat }
ifelse closepath /LPutVar [ x0 y0 r AngleA AngleB h d ] cvx def /LPutPos
{ LPutVar /d ED /h ED /AngleB ED /AngleA ED /r ED /y0 ED /x0 ED t 1 le {
r h add AngleA 1 t sub mul AngleB t mul add dup 90 add /NAngle ED PtoC }
{ t 2 lt { /NAngle AngleB 180 add def r 2 t sub h mul t 1 sub d mul add
add AngleB PtoC } { t 3 lt { r d add AngleB 3 t sub mul AngleA 2 t sub
mul add dup 90 sub /NAngle ED PtoC } { /NAngle AngleA 180 add def r 4 t
sub d mul t 3 sub h mul add add AngleA PtoC } ifelse } ifelse } ifelse
y0 add /Y ED x0 add /X ED } def /HPutPos { LPutPos } def /VPutPos {
LPutPos } def } def
/Tfan { /AngleA yB yA sub xB xA sub Atan def GetEdgeA w xA1 xB sub yA1 yB
sub Pyth Pyth w Div CLW 2 div mul 2 div dup AngleA sin mul yA1 add /yA1
ED AngleA cos mul xA1 add /xA1 ED /LPutVar [ xA1 yA1 m { xB w add yB xB
w sub yB } { xB yB w sub xB yB w add } ifelse xA1 yA1 ] cvx def /LPutPos
{ LPutLines } def /VPutPos@ { LPutVar flag { 8 4 roll pop pop pop pop }
{ pop pop pop pop 4 2 roll } ifelse } def /VPutPos { VPutPos@ VPutLine }
def /HPutPos { VPutPos@ HPutLine } def mark LPutVar tx@Dict begin
/ArrowA { moveto } def /ArrowB { } def false Line closepath end } def
%
/LPutCoor { 
  NAngle 
  tx@Dict begin /NAngle ED end 
  gsave 
  CM STV 
  CP Y sub neg exch X sub neg exch moveto 
  setmatrix CP 
  grestore 
} def
%
/LPut { 
  tx@NodeDict /LPutPos known 
    { LPutPos } { CP /Y ED /X ED /NAngle 0 def } ifelse 
  LPutCoor  
} def
%
/HPutAdjust { 
  Sin Cos mul 0 eq 
    { 0 } 
    { d Cos mul Sin div flag not { neg } if 
      h Cos mul Sin div flag { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { r add neg }{ l add } ifelse 
  X add /X ED 
} def
%
/VPutAdjust { 
  Sin Cos mul 
  0 eq 
    { 0 }
    { l Sin mul Cos div flag { neg } if
      r Sin mul Cos div flag not { neg } if 
      2 copy gt { pop } { exch pop } ifelse 
    } ifelse 
  s add flag { d add } { h add neg } ifelse 
  Y add /Y ED 
} def
%
end
%
% END pst-node.pro

%%EndProcSet
%%BeginProcSet: 8r.enc 0 0
% File 8r.enc  TeX Base 1 Encoding  Revision 2.0  2002-10-30
%
% @@psencodingfile@{
%   author    = "S. Rahtz, P. MacKay, Alan Jeffrey, B. Horn, K. Berry,
%                W. Schmidt, P. Lehman",
%   version   = "2.0",
%   date      = "27nov06",
%   filename  = "8r.enc",
%   email     = "tex-fonts@@tug.org",
%   docstring = "This is the encoding vector for Type1 and TrueType
%                fonts to be used with TeX.  This file is part of the
%                PSNFSS bundle, version 9"
% @}
% 
% The idea is to have all the characters normally included in Type 1 fonts
% available for typesetting. This is effectively the characters in Adobe
% Standard encoding, ISO Latin 1, Windows ANSI including the euro symbol,
% MacRoman, and some extra characters from Lucida.
% 
% Character code assignments were made as follows:
% 
% (1) the Windows ANSI characters are almost all in their Windows ANSI
% positions, because some Windows users cannot easily reencode the
% fonts, and it makes no difference on other systems. The only Windows
% ANSI characters not available are those that make no sense for
% typesetting -- rubout (127 decimal), nobreakspace (160), softhyphen
% (173). quotesingle and grave are moved just because it's such an
% irritation not having them in TeX positions.
% 
% (2) Remaining characters are assigned arbitrarily to the lower part
% of the range, avoiding 0, 10 and 13 in case we meet dumb software.
% 
% (3) Y&Y Lucida Bright includes some extra text characters; in the
% hopes that other PostScript fonts, perhaps created for public
% consumption, will include them, they are included starting at 0x12.
% These are /dotlessj /ff /ffi /ffl.
% 
% (4) hyphen appears twice for compatibility with both ASCII and Windows.
%
% (5) /Euro was assigned to 128, as in Windows ANSI
%
% (6) Missing characters from MacRoman encoding incorporated as follows:
%
%     PostScript      MacRoman        TeXBase1
%     --------------  --------------  --------------
%     /notequal       173             0x16
%     /infinity       176             0x17
%     /lessequal      178             0x18
%     /greaterequal   179             0x19
%     /partialdiff    182             0x1A
%     /summation      183             0x1B
%     /product        184             0x1C
%     /pi             185             0x1D
%     /integral       186             0x81
%     /Omega          189             0x8D
%     /radical        195             0x8E
%     /approxequal    197             0x8F
%     /Delta          198             0x9D
%     /lozenge        215             0x9E
%
/TeXBase1Encoding [
% 0x00
 /.notdef /dotaccent /fi /fl
 /fraction /hungarumlaut /Lslash /lslash
 /ogonek /ring /.notdef /breve
 /minus /.notdef /Zcaron /zcaron
% 0x10
 /caron /dotlessi /dotlessj /ff
 /ffi /ffl /notequal /infinity
 /lessequal /greaterequal /partialdiff /summation
 /product /pi /grave /quotesingle
% 0x20
 /space /exclam /quotedbl /numbersign
 /dollar /percent /ampersand /quoteright
 /parenleft /parenright /asterisk /plus
 /comma /hyphen /period /slash
% 0x30
 /zero /one /two /three
 /four /five /six /seven
 /eight /nine /colon /semicolon
 /less /equal /greater /question
% 0x40
 /at /A /B /C
 /D /E /F /G
 /H /I /J /K
 /L /M /N /O
% 0x50
 /P /Q /R /S
 /T /U /V /W
 /X /Y /Z /bracketleft
 /backslash /bracketright /asciicircum /underscore
% 0x60
 /quoteleft /a /b /c
 /d /e /f /g
 /h /i /j /k
 /l /m /n /o
% 0x70
 /p /q /r /s
 /t /u /v /w
 /x /y /z /braceleft
 /bar /braceright /asciitilde /.notdef
% 0x80
 /Euro /integral /quotesinglbase /florin
 /quotedblbase /ellipsis /dagger /daggerdbl
 /circumflex /perthousand /Scaron /guilsinglleft
 /OE /Omega /radical /approxequal
% 0x90
 /.notdef /.notdef /.notdef /quotedblleft
 /quotedblright /bullet /endash /emdash
 /tilde /trademark /scaron /guilsinglright
 /oe /Delta /lozenge /Ydieresis
% 0xA0
 /.notdef /exclamdown /cent /sterling
 /currency /yen /brokenbar /section
 /dieresis /copyright /ordfeminine /guillemotleft
 /logicalnot /hyphen /registered /macron
% 0xB0
 /degree /plusminus /twosuperior /threesuperior
 /acute /mu /paragraph /periodcentered
 /cedilla /onesuperior /ordmasculine /guillemotright
 /onequarter /onehalf /threequarters /questiondown
% 0xC0
 /Agrave /Aacute /Acircumflex /Atilde
 /Adieresis /Aring /AE /Ccedilla
 /Egrave /Eacute /Ecircumflex /Edieresis
 /Igrave /Iacute /Icircumflex /Idieresis
% 0xD0
 /Eth /Ntilde /Ograve /Oacute
 /Ocircumflex /Otilde /Odieresis /multiply
 /Oslash /Ugrave /Uacute /Ucircumflex
 /Udieresis /Yacute /Thorn /germandbls
% 0xE0
 /agrave /aacute /acircumflex /atilde
 /adieresis /aring /ae /ccedilla
 /egrave /eacute /ecircumflex /edieresis
 /igrave /iacute /icircumflex /idieresis
% 0xF0
 /eth /ntilde /ograve /oacute
 /ocircumflex /otilde /odieresis /divide
 /oslash /ugrave /uacute /ucircumflex
 /udieresis /yacute /thorn /ydieresis
] def


%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/psfts{S 65781.76 div N}N/startTexFig{/psf$SavedState
save N userdict maxlength dict begin/magscale true def normalscale
currentpoint TR/psf$ury psfts/psf$urx psfts/psf$lly psfts/psf$llx psfts
/psf$y psfts/psf$x psfts currentpoint/psf$cy X/psf$cx X/psf$sx psf$x
psf$urx psf$llx sub div N/psf$sy psf$y psf$ury psf$lly sub div N psf$sx
psf$sy scale psf$cx psf$sx div psf$llx sub psf$cy psf$sy div psf$ury sub
TR/showpage{}N/erasepage{}N/setpagedevice{pop}N/copypage{}N/p 3 def
@MacSetUp}N/doclip{psf$llx psf$lly psf$urx psf$ury currentpoint 6 2 roll
newpath 4 copy 4 2 roll moveto 6 -1 roll S lineto S lineto S lineto
closepath clip newpath moveto}N/endTexFig{end psf$SavedState restore}N
/@beginspecial{SDict begin/SpecialSave save N gsave normalscale
currentpoint TR @SpecialDefaults count/ocount X/dcount countdictstack N}
N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto 0 vs rlineto hs
neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale ang rotate
rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}ifelse
scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale llx neg
lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly lineto urx
ury lineto llx ury lineto closepath clip}if/showpage{}N/erasepage{}N
/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{count ocount sub{
pop}repeat countdictstack dcount sub{end}repeat grestore SpecialSave
restore end}N/@defspecial{SDict begin}N/@fedspecial{end}B/li{lineto}B
/rl{rlineto}B/rc{rcurveto}B/np{/SaveX currentpoint/SaveY X N 1
setlinecap newpath}N/st{stroke SaveX SaveY moveto}N/fil{fill SaveX SaveY
moveto}N/ellipse{/endangle X/startangle X/yrad X/xrad X/savematrix
matrix currentmatrix N TR xrad yrad scale 0 0 1 startangle endangle arc
savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
%%BeginFont: LucidaBrightCE
%!PS-AdobeFont-1.0: LucidaBrightCE 001.000
%%CreationDate: 18.02.00 at 15:55
%%VMusage: 1024 47599
% Generated by Fontographer 4.1
% Copyright \(c\) 1998 Bigelow & Holmes Inc. Pat. Des 289,421.
% ADL: 800 200 0
%%EndComments
FontDirectory/LucidaBrightCE known{/LucidaBrightCE findfont dup/UniqueID known{dup
/UniqueID get 4890615 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
20 dict begin
/FontInfo 16 dict dup begin
/version (001.000) readonly def
/FullName (LucidaBrightCE) readonly def
/FamilyName (LucidaBrightCE) readonly def
/Weight (Medium) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -200 def
/UnderlineThickness 100 def
/Notice (Copyright \(c\) 1998 Bigelow & Holmes Inc. Pat. Des 289,421.) readonly def
/em 1000 def
/ascent 800 def
/descent 200 def
end readonly def
/FontName /LucidaBrightCE def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 40 /parenleft put
dup 41 /parenright put
dup 44 /comma put
dup 45 /hyphen put
dup 46 /period put
dup 49 /one put
dup 51 /three put
dup 65 /A put
dup 66 /B put
dup 67 /C put
dup 68 /D put
dup 69 /E put
dup 70 /F put
dup 72 /H put
dup 73 /I put
dup 75 /K put
dup 77 /M put
dup 80 /P put
dup 83 /S put
dup 84 /T put
dup 86 /V put
dup 88 /X put
dup 90 /Z put
dup 97 /a put
dup 98 /b put
dup 100 /d put
dup 101 /e put
dup 102 /f put
dup 103 /g put
dup 104 /h put
dup 105 /i put
dup 107 /k put
dup 108 /l put
dup 109 /m put
dup 110 /n put
dup 111 /o put
dup 112 /p put
dup 114 /r put
dup 115 /s put
dup 116 /t put
dup 117 /u put
dup 120 /x put
dup 121 /y put
dup 122 /z put
dup 228 /adieresis put
readonly def
/PaintType 0 def
/FontType 1 def
/StrokeWidth 0 def
/FontMatrix[0.001 0 0 0.001 0 0]readonly def
/FontBBox{-36 -318 1014 993}readonly def
currentdict end
currentfile eexec
D9D66F633B846AB28EDC112EE8CE6C673600130707DE48BF082E5E38F377870F
EC577CC0BE324DC9F48DDE3E42F41F80F0529CA4D00437E413B730C2971C6596
BC0E5C3CB3B0C4CB00F49710EE39BFC08B25EE73EE0110AA0B09087B61961613
F28957190014C668EBE72F94F0C3F59D322B6654935C89D08228D87A26CB5A02
2AF72D68BFA18797C9A4FCE0EA5F267180E8BBB3523B860BA31385E6D13FB249
82A8F708AC7E7D555EF420CED2D8DB13A0496426DF3157841D9CB57CA0874D6C
1664C8C8A9CC63CD76B945A2969EA0EA63C31EDAD9E7870E96E3E72336D46967
E2EA0D0FA5AA4B8604D019149C8957096EEB1BEA900ECD03022DB5142AB0A1F2
A0C71498AAECE590586CA1F863B9E9AB06D9E27AC5D1DA50CECFAC74079A60A4
F6230379CBAB3461A106E033B6B59B40E8D65D99E65021394297EB3507ABE8EA
DEA26615E1210C21B30725C3640860849878C424D06E3DD1F22F0A674109204C
A95519D84EFC3F1B77BAE0B13BC5357B109628D853AA0833BF4B06CB19D1C124
0FD5E1ED6C9E910C32611762700E6475AAB74B8E9FA547ACFB7E9B2B15F1D5A8
9543DB47255A2C5443BCED6E28F46E079CF27120ABB9917BBDF765C662C25C0E
1C118C7B61DEF5D51FC56896A34EF0F1657A403654044F0315DFBD0783B71787
2DB951A9A1A36F27A910774C31F7E1D0878CC6570470AF607FBB369CB6BF9F66
15B04672B879998517BF99B9E4F0ADD769E5D41AB933E3E6DA8EC54BEA6E431B
7A5E2DBA54549224E46E3C5E5E9AFA5541E4775DD42FA9522E820F5D07539F1A
FCFEFF7376918A35C7EA8C1A0A48D9721A86BEDEF76AD6F32D5A3768FB6BFF5A
1E7BEC988F06F62E178393E8BB74CA37E8D89DC67C0F9842B0368AD7A499EE5D
B75C1A20FC3A555708DD7932F8863383E5851027BBE6D042F65CEFCD3023B738
6FD34E7056F062F57B7A5DA64B28AC1842A8F42ADD4915D8D4407C4A868FD4E9
256C6E8561AB69E56C391001D99B860BDFC3508BE480018EA7760738963A66B9
B5D897A3C67A2462C67F883413E087786C64C752F930E609AA90D47A1310422E
1AED61C75904BBA4E3377958FC9412767223B29BC367F1C0A4313FC57A916CF9
434B2384EB1ED34FF52F9C9E0D3FB5901AC4BB19D8066FEB0E9B16FA1385BD5F
1B653894A952257D37FF0E25A81CA7D01F5A103CB3F50F1D88919C419C91A650
AEE18C8BC3BC1633C1EED8854448063316B83CB4058BBC339DF76BAFABEC1D78
053982CA60D0A2B591F4139829FC1AE5BF699E0506DFFA5739E88BEB81076CBB
0D25D106A2E0B77B2219F8DFC93B00AB0E2AAA910AD5C7C4064B4DEC8B2A5378
89B206A137DEB2509F6AF2C908FB12B5D161B63A9E42CDAF15BDA866D575DDA2
FAA82DBADA1FCB2770B15579D50F03C3B45ABA5EA21743669C87A0D99DD594E1
C3B520A779331BA4EA61ACF225D27F2C179B139811BF4EE0281A610B03592111
5379F02C527E4625FC0A91AA222524C6AEBB402EDC33ED2C6C1BBD8827527917
8552D080E2A715B0E16C82BD58EE66C622DE285C8B2BA420BC87B3E776FAA4A8
E3A31BC6C19C309C72BFD7EDCFDF439B2B05CCA4C3C1E3AA750E86B604B81F22
B414AAF0E1A95B47BFF24C4E93AF27FB1BE92AD979EC491ADAB58E002E8A1762
5632601A8A2CD0CB820C71C9F09504A66E08D42F0A1D4CE48EDFDBEE06EA244A
AFDABAF7A8C06C8C61F288B8E820FB0228863CF12161FA0A770ED6D39E571D79
E7ABE0D0583038C3346D7FF6A92E3A15F5BF0D75F30CE83E1D5AEC2C330B4F75
B39E74BA104215F3C12D51650AAE159DE6E9FE620D86E9B05E900D14042BF7FF
0CE1300F22FE7136611595047CE8FAD26EDB09844D3209B64E00A86B9E3CDE75
D72CD14E5821A476F51FF61C1BC23091605CDA81DF7AFD6C9BB23D75C86DEC3C
DAAB810C2E0DF5239BF33993123C80F7C2A81D666FC998798BDCD371CCFA568C
79AD7D9815E0BD34702EFF739EF974989569AFD6AC2191776FD806E84A974A00
C1807FEF6F0AB2532B630445F8B4F7F4B975DB8D7E5D664C30D82236EEAF7236
E220EFE0D60DB5E9D3E39B24A78AB2C62629C048F320F7045055F1636279052D
63383C0D35946F084C8D59321F918EBFA21910AB452424307E0C5685C0E79759
DE2709F47847F981E61F7E086A867FE874762CEEA7BA9CABCEA4DF01C72D51B2
795B17073F7556030AB9C797372FA41E76391B55ABCDA623F55A3E82E5AAA694
7BFB2743C872FCBBB373AF6421C788FB9264AA9D82F4E5DA9C8513B9A0AE52DD
248ACD3FB6AE7A99FC866794AC1F3365E5792A46A5BFF3BC69D0EE356B34D0B3
801CC3432BC8C99AC01A0005FB2EE6FC30FB29C0FF50BB1D23CF91DD906AC481
E28B9EB73E963DEBCF119B1A1F627D6E78CB328EFAEDDC0D51EBE0C2888B369D
421BEBB6E7FCDCA196ACDC62087BBAFA394FEA400984FE53C5E61C03E3930585
CF95DE2F4696D2F24B8A11518C65601D62FD795E1A67EB300EBE8891A877C3D7
B0F0D6AC90858CB2DF7CBF17F5C7B10288D40B623A22FE5D9CB9EE4B758840DF
7BF9C8949FC4335BE0FE6D0F6493ABF0629D1882ED5CAD28D7AAAF5DB961F79B
776580EED2567976EFDE5F160A83B6BA54E9A92DCCF3F80A8F6E82B0C4BE159F
1FFE69903E315C601C5CDBF7CFFC95F27EA0792C87DC525532FF2370583B082B
75C735FEC6D53DF6A7895FFAC9A8E8D927EDB7278F17D62CB86F2BDA69DFEEDF
76DD11EE009AE4AEFE178AAC68F5FBA0B930BC84861CE5D9CCC2ADD97B114725
E11C84F7F6E8117D338C6A5B59881ABB66ACCCDFF457EF70D7E213898246A0F8
E534A05D9ADBD0ED6FF22ADFC529E2149B9A574F6D08DAFC69C29F305CF08B57
79488F15A313A17F552E5E69ECA25F35C313BEC07F7852D31DE56BE21DFBBF93
05092E87740A7F60F5C7EF6573B1ECA3D9137DF5EA301BAF0E630B0B6253D36B
7012C80E9E3C0FA10D0B9999D2330281D9057CFC928132D299BBE6A6DF9744D6
9C71E4396905538AB55686AE4DBB1E3D7AAD020E7A6C7790294B0330B852B4F2
2B1738CCB7933CB706D9172025B1E100423F773B45583683094D4E3A93B7892C
1BE21A3DFC7CFB35E19025DC0E0BFE1E8724866EEE2F9B557A3757C3CC58920E
82E0B514384EEC28B33B84D075F46EAAC0FDB0137341CD04A8B52471908AE151
534D5FEACD9E7209572BF049A41F70D637D76DC345472CF61777CBA7787E9550
82E4D4C71396FA6A537641AD4D2389EAF3F0F6CDBC26F6C64562846FC73B3324
0A73FCE50DFCAF6C4F15600AEC20578682D9B00A2C6589C92DB0F1FBA5921B8A
62BAF30BE5AF104DF56B8A107A8AD29F105279381C986BFCAC77A376E7AB677F
94165CA9A108DF5CF4A938FED50331E9E39957A90D3BD69E1C978CE26B683CDA
EC7BE97BCB940256D1E23DF701BE018D951E64F7145DDCD6AE768A910C3E5A31
1BA8D8C69352B12EEA916B4487EDE3762AFA2EF766F57F2358F3022B1BF94866
2136D3385E054C5D5741E6D0A3A34950438EB4067CFBDD9856B588AD9FF43739
AB26B223E36F4959258BC4C04B151259EF4854FCF903B9358699BA59C3457871
CF222176E7778A3DBA7F996B3BC60101A63F9519ACEE1E468BB222EBA8BCC3FB
7DC371485B9A63F7B6FC2902B9AC5AC550A7A7EAFD6293CDD986B41131F4D582
2FD6D5CC31DE06F192528B3EE7DE6EE6ED53B51E9DBB15BDF6B9EE5C277DF354
FCA6BA5585C9C545650D7538342D32DACF923BACF30683B8CAF4C3BE2D9805BA
C811F8662ECFA7FBD623B9C73846D0307F36D19FF321D2DF159515D48A32BA14
745AE580CE51356C6BFF5C183EFAB82F66B1E76D7A62E0F9FBFE98E3109EE9CD
C913937A28AA74915A858724AD3F58F0B9315291E8C70C28CD49AF3310EDDA89
20A1718DFABF780E8557602DB8EA63FA566CAF1518C0261B218D2D9F5FC3C429
0F59F715AFF98FF485CAB673A38A4E58B37645CC0FAD687060A72F4B6D6D9069
A4C5D612B6AE00B6F9241A358FB12B1DA0CF354D6439F1D6EC4210D9AE49D496
3540E8B10E468F53F770A7C333779043E79F8E8E49FE3B554A99A282BEAABE0F
3D35EBE6927D4BCF1DAE5ABF4CF9E44A55EA019EB1F8B3A21B85E8440728FDA6
E785141F6A283FEA15CB2E04FC8987D0BE71AA3565519DAE4B20A20139899C76
E19AB5711B78B077D12978922A292D4425136AF93799A598C242E24459A1A63D
F29CE90F42FB3D7454635950FCBFD60E695FB562A50E863DC8E42BD1129BA58B
63F5EAA7169F949A65DAEF9124BFFE4D5DF1F7711B9DCEE9DCE113EAB4060046
CA992C26D7AED7CFC38089CAC56D5F9897EC3E628459A56788D6B03933BC5A46
877014ED1D703AB7CEE1406128111A0F2A5474B5A03ABE84F8A8701FD2BBBC1A
2F096AC0AC54A0D23F8A1F44EE26D9FEB4799D814809FA0B508E468A40208640
B2C47992C48D7EA1794DF5341F1F8AE0C8F5ACC6DFFB79EEDD6FD3B720900DBE
03AA6EEB9CDF7FAD505C70454BA0FB883E2415C26B284407AC7D4C602C8ADEB4
BBB9AFBAA5B44457DCC42D0AEB2F948A60B4833F50BD77859C6F8B975CE5A164
E375EB1D42FCD94DB862977C6E6A9718C83840EE024F069B5F1E2927A923950A
811661EEC30D6F3789DE80CA4729DE366CAF8B32164A530FC3B04AD9377E1EDC
8E550C3ECABA1556101AB8278FA596F460F632CCBAD91AAD3684B6973AF3B543
D5AEE13391B8D65BBB189C0D5131960E2426D48C9E07EC15EA94362050C667FC
861ABFC947E52AB59BC1F958AE8963F5A945CDA944A2DB91AC2F9D1D1E63C48E
5FE7A555F73EC3ADFC1B786770E19FAA2364B8FFECC695478C95394775A5936E
6F84955BE446E9CA13674DE40BBAAD2039060EEAF750ABD433FC540D43FB5A57
93886D68F7581E85A4761FDD281913462FB5E925F8D8ECAC334ABBE8756D8BC3
5B5F8D8F8C0097F40056173D3AEC06AD95E9B1ED681A9A7F6E1BBDA383AD61ED
B35952CA895FF526029A799122AB79F06F6890FCE493CA7BFA6285F7851B1BAB
F419AC37A61EFBE823569245AB01DCC45821DD1B1ADDCD46E226A4B4502AC8B2
62CCAFFEA61B73EB6ADB9E0C12CAAC426C9F1ED39E7226F3430A260FA7D82BC7
620DC66D883D40753BCE01231AFD9DE187FCBDE96C278336A37813EEACFC530C
022F381794B5F27EC031FC1DCEA982D8412EE373E92B4190C97D3DA3F5DA339C
5016E4A0330A11423AC54D0DE81DA44D2058F65434A44F01023C3EA18373E083
9BFA31AD78489B7E2495EAC1F51C743185D3E6F2A34C37B414A8F93F0C684E38
0364C3E1C2E75007CC38A310DCAAF98A9C750C80B809668BEB0B6810362198FA
1C23C00AE41C417A58B41B301FE702313064066D86B9AEFE97DF38222D9D9FED
D6052953FC39219028ECC8FC90900EB593BC5EB16A0F8C8C26C710FE8F5A804D
AA354B808D2E303C24E83312E06E366C59141943FACBD6998095AF52A963E7A1
FA942A4FDCF44F55522465B82A18A4DF9199D9F46B1C2E0D5397F0A7AB6A552E
AC512EEFD176FAAC23991F465B3463F4253AD4BEDDC933C420A4F1F02E9DD7FE
48F779E08AFED30209D7A9EC92CB249770B74D6F82601E4F4F10956115CD956C
3B1F420EF3A6C0198E82B2A7A84397D66B32BA0CDDCE057612AC14E3A0F9966B
F78DF3FC010B4B0ABCB9EF44046E7443C87A035E4FF44D086C618E7C7E3ADBE2
404698B4041781DA590D73A58A49B43FCEC92B58D50410B32A75F3FA0F07FEEB
1BB4540B375082BA01A325F1AB3EB48758AD9968195575CCC2B294E10F8D84F5
7F49C4B93E7E23965B6CEE228B17D1E569FC53F95A6CF24EBDEDDF61B263C632
F02DE118F608AD734DE71E321844E30CA564C93008D1B39275C86E03452E87BD
2CF46FD9ED6D7CB14BAF17916972B08021F5CEB2E85EE91447E4416D379F53D2
BCD4825B12FF3EDEF9F439F146195F44C20B05C0E79E2F3FADAE612CBBFFCBA5
07610B525421DA25B5023E851755445BE59AAEBD9E31CEA5E4DAB941907E63F4
5A855D9896C783C88ACC8AEC447A946371E7F5E77EBA05ACF43F9F702018C5E1
9EE407FEACF7A8B252EC73B2ACD5105460D430DEE2C3B78C80D81844D804B98B
30A1BE22B7278FBF24FECF61BA13A4F35A14259BB04BF74D17A7E7B7FA28CC91
2099DD510B0EBD7394B26ECB33430C94CC4B3EA14374B4B838AEBA14602C876C
BAF1CE4A9D6B214375AE9E5BBEA54F424C4151D3FF6D442FD287B217C2D53A7D
5DE74662007FC8B7F8760D774FF93506EF1C2FDDE46788BCA28B9DDBBEC0D8EA
20EBD944FC83F7ABD0EA77E65D2F1B736206CB5E1D27B1EE8AEB42141406E314
C2DCA94941F67F5CC0D788F43A3ABFFE4EFC9A825A69955682D36FFA18C7B5A3
B5D01EE4BB944E9E0F8CA438EAD2B679B02B621BDA36CBAAF6395F158B699130
E5CFB2512D99A1E8DE1C9B1EE13AD831924410D38F1DE14AA1F7D317A8F2E3E0
542F59CCE9DA35C4878768885FEF99F21F9E9DD0B99C10A99B5D728CE0A72269
545AC304C7998EB92BD47C5386AC22D9CD51E6FF45000FBE1F2F09F90EB265A8
8B2D70B1BC088816F600A29AFD4FCACF313369B08959A6ED478D5874ACAA1B68
B03B03F4DD7E58E93D92AA0A0BC28A9E9C6762A539494A890C9783D36B86BCD9
AD173CDE0758F5B20F8292E6A504EF03FDA016763798BFF14410EE4E592F74F9
9A92C79539206E225CD94ED10689BA313C26455F144DC6CF4B1AC99FF1265672
89FC495D0B8A49A60266C06C598B7B372CA3694D123F7B05ED102BCDC0A9796A
D77C4F1D3D20C0F8FDC33D6C6DA3252F1DE65D98501CAC77972C876D1F206339
3A2931084DB63E40DEADC6E7B1C27DBF88F5BEF7847F72DDB2684FBC0EA0AEE1
C056A081F0ED0221EF59B0E50DD9B3E10DDEBE07138424009E6AC35F702FD182
2D1BF5BB42C63B7D68ED3F0234C5299B8ADEDED4E5A3034FBF77430CF4BE91C9
19F8B1693B30997642103F1170B861EDB14C98A278EF133537A9D188D1282D7E
B21E424025D52A99BF82E818AB3774485E5CA20116033B6F76D225B6A0350EE9
1A935126FBE34C4537BEFA6A05209E0B8EC443A306679A8C2A59135421B9FB51
B5F9867A1EBA3E76EFA33FF01CC61782F00ACE57ABE68C5AFA48D7FCD737EDDD
84F9B347D390A5A7E1BC307679BB976680D65FF2CCFE31F94B4357757514EC17
142C398FEACAD6C27F7E781651E5590242EED22529D4B32E159563231F3091F8
EBB51035A54E09DBC6EDBEBEF8D5B486887C6D7A1B91FC3BE0253A0100688CFD
285EC3F16070CC2FEE2604E7CF4E962D60946B473BF174DBB3617512C38B9DD4
31A7C153FCF68BD9E4520C5E3449E00EA0ED7A4AE8BCFEBE6DA65958730B298F
B50C0ACB145D69FCCB1A533548F122D5CCA2CF1AF421DE5885059FF65FC122A4
74541E8CB59F977876DE92D679F58401F2083E961D448568EBCEDE7F07CDEDA6
19904F826E696C34C6CAFC680303670F28FB26EC355087082F3DD7597E7126AA
68E1F3334F4CD9243AC9051FAD8C76DD61330D89A58DC1E94D738181135CA376
00BB6658A2F38D4C385C2D0D39797D973A647D2BA79EDBF98EC34EBE0982779D
612146B6EB1DC13C4BDC92EBEFD46B20FE0D904211BEEDD16EFDBC9E878B1495
2BF7F5D38679388AE320D5D4A64DA1B32197A28A6B929BABA470EBA78A91A05B
604B42C95D4BF56B8602C2C1E539E0C49AA936AD9F8C3692F150008D1006EE5A
EFDF6E4E08782D9A67D1F63067F269C29CF655887D56D4264FEF5A3167EEC777
C1F722A92E5C5AEAA1A20E9D82E3C99CBB6F1B331A441C5F8825737950A32D13
8F48B49A783D379C5BE3788106A47F1DF1B49C8526B85D82941F2064732C66FF
82561D06AD28654187A6F502AC3178C8014D1943E287A2EF30D1497989840832
A089DC38F5C36361FB506B815224640CBB4CB38C5D56D6970447D13D1E8A7637
AE112A86DA9B2B0726CFAE85B918BF848816BD7F5BD18E974B38C77734565AE3
FD487B855D2D65136B39A73FA7B66B4DEB01EAADE01972F5D39FFCFC3765E4E9
47C1F855F43F49E67D6D9577CE32212096AD99CC00F93C0893F027C5264C4783
65F434BE3561981A6F71084F39228156080E61A5CF9F8AD165684778BE5D1214
1D01BC7C7F598BC28C87E6DEF4565D8A63388F93D5529DFB7254409A74CA5C78
EF4214775FC75D89CB86B88BC6030F718F50F7D66FA9F74AC255681B6ACFA49A
0074F80A00339A36503478382D32E699C448B9303DF152E77E7573B535FFB40A
AE424DAC6A9AE56B39CFFE0B0367B5F4F614563DE3B4CA30586318CA250322A6
681B39CFD58D9E7958AE206C8F2DCE01D899C44CCFA1D198AA44501ACC6B8CFE
EC811899F75825B49F396EED17D95703CFE367B5BC06617C356E5619F9CD919B
654DFC2F2ABDDD6360150D8A976058EBE34D113E7475480681AB0A1FF0580BE1
FC9F7BC36EA193D2164B2EB8D623AC874E83A3A28724FC8EC1B5A9E5ADCE8462
D4AF1963BA1A9F28932C04FF17AB32747D2416C856F1581BC01794D15B0BB02F
8BF8CAAB12843316FFE1211F2F595EE6E3AA4488654A16340147ED0B203E3456
5410A26D8C9F2115E4156BEDE05CA81819FEFAF953B5193A4C3136FB16885F33
CEE94ED70DB203C109E7D414E9969702D73FBBB31B4D82E3AAC88EA8D6980725
7B88186C5DEF881E4DC65D44990D5ECF5B8504A3CECF4206E28308AE776244EC
005297EF7326F01704BD18ABD49E04FD0D7E7E519B1F038DEDBB3185951D66D4
4BE8D61B18621E12C6B02C411585F53FDD0F68EB0B5F6488A928B5B07EE8CA0A
94600DE7113D253CDE2C76B3918A56E922A9724E7872C7E290C60E0CF644E3C5
24EB1E65114E465229057EE787E736A981E1918D8FE798631FD4FE51885A5B65
C14DE540F379D3C3C0F09DFEF903BBDBF66C563B1C62A573EB0603EBDCFBE84B
03677AF26C01317E5200D904E305FF3136593C252F8E623B37652A0E484C539C
A9C812E95CFB0B9824F8EE9F97A4C0C2E935BE89DF8C762937D25A392E01178F
95F0D1A6AE42D57C9409A96281BC088472F8CEDED2DBA08DA84BF6179C7DACDD
45F7DFA8D152161310F5B198FE8D4D7009A18799C7757FB47F029BF5F01B913B
4C66EB2D59689D5CD72BC59E13C7210D57629DE10685B1FA508DC3ED49DEC9A9
4ED1D318ACB60AA416F6729F0DE5C57A0EC29C4E130B0487DB674BCE6F811BCD
F07DCFF5EC6B2384636422616E6D657075F5E01F783FB4F3EDC22E9EF3DE5068
5690EEC6F5278A7BA6E2DAEB8084095B465E2F66E5102435B8A904848B708C59
4997C66384E433D8349BD5238FFC9D69022345B02BAE6A3DE412892DB69D7B89
EEE9266625B8EEA74B72EA9287307F64D91556CC94AA1D6CAAFCC6D6156D4F1C
E3EA366B16666D20599886ABA8734B92776748E5EB53D5B30F6084F7AB201D5E
716201027D7C0ED2F4966C0ABE9BB774763C7C5045C1A3F72B11069E13117E11
7CC6885E1E852ECAB4BEB313DAC59534055C45774180E763DCDDDE64DB3DDB11
50BFBDFE2A4C1D595F0017AF147BB002506089FB5EBC57B74283D5F732770BFD
58B902E45847FA0022E7B6DB9FE55D07C7BF57A6864A7734844CC534ED9951A1
22DA3927A2A8140922EE41524F0BCE548DADC047A0489DDBE9CC612336CF5CED
21130586C0F48CACD6B13F932F76668D4532D3127599AE7037EBA388BF0E4879
6A1E4CBFAA0022EAC1D44615E450B6F99522F2589D3459AAC8DD9DB8B72BCEDB
25924053F6809B3D25DA50E29C60E76F1E7F5B5320DAAE8656E939C45D05D983
BECEBF267FF41F617766E30226972BFAC06D4748DFFFAE2C2D5E0003D4B3F239
3A7FFA021D9AC4A2B0B62221DE0FD9E3D0EF80A592A2CFDBF306C4946BCDB069
89584B013936438C89A1B42F77EA19EEF541BF1B130CAFD5D9692E48B0498649
B1B7D24F131238080A70CD38D4F83CA05611C4741AEDADA722DC233AC6374874
82ACE403CEDAF685BBA04CD1441394577550715434D80BB574B091934AEB7FCF
34A38A7C99A8E40A1527C47684FBF8FE6A0F51D1B216DC0863C1C96432199161
C40213C79B0AD5FAF233A64B2029406DFBC47C8C5255541B6B4F1AF04EEE2D7A
7B68C47BC7BE7BF018A2B89A392E617A066256F393FA05924C9145D014FD9152
B986C9E79D60F451878709FF0F3540B7466DC199221386CE348B65C98AFA536A
33D0B685ADDEAC414A479B3EF27D5988B51FDED72480F6A1A43340DFBFA9DD75
D55D383121F9E713D8CEAE6AB1B297A1EC2E1196DF48E6C3589E5D0558E9C6CD
17632CC09EAB03F728BC4C67F7E173D6E9DACD99BA670244FA34CE78BA7807DB
C4F4BF52526017748E10F1EB223A96C6D76D50F9513FC5807D76103BAA33C2CE
4F959E6DCE32DD8EFC78F4457A05DDD932D4ACD754959A236DB415821A93D7DF
DDD91AFD8BDC659B59EB5B84A49BF6535562013BA7112D078FF1B717760C31F1
A7F75F7FE7831849BBDC507FE875369F49680F54737973B85AA5DE4789623172
4F09FCE02078234F752BA08CC6520E6051C93DD85D1677B01201D20BFD57AF70
A0CAD6791D6B466F815468C5EACE0F9B1A0BE397E9695081348F752DC3810683
272C67809BC5D021A412A7D31E55B42B6CABD4DDA8D917D7418A38505C2C2F57
C9B9155FEDFAA3017EE7D1C75577E347FBAA585B35C237099C14C9A7ACA5529C
85AEE0D6E20317A3E6673CDE5E7ED8B4B983DEFE2C73C31BBCDCCB101919A6DC
FECD12CC142523BAED6F78E28FAB02E804590664DBBD4AA4A6992F02C1E054A6
0FA53DCEC02036554C89A8BA6BB1CD3121E5388A55600481CF8E0C0952F401D6
C3EA92D314164FF8E335035081D3C5AB43EEA5462A96EFE50CE071E6C17D1CAF
E58E244998FD425014E0B0B54B49740E82E0221DE3D863DBABFEB39C3B1AF4EC
CBA498F2A4CFF965DF4DBC6383F212D5427813CE902BF8E30B0B85320FD502EB
1B0E606B6A5E263648CD77C9F77B731029DA91B5A8AA22F401D844112C004E24
83F0AE30D89C5A78F76AF0772D00A1E0BEEEC3E3ED5DD84C90EDF242277963BB
341049337AC3F33CE02DE93E8F5FF463A788A14E02A522F039FD7D26B0BEFD97
BE429A0F527D7182EE133C5291FF35C7F269E1EB73575EFF92D9328B39406063
3A5C0F208ABDAF933DDD2F48A1E8571B418FB32AC6686B4DBB1FEB65D7858678
296D85EF316648D079375800EC712627B34926CF41C542F491472F5798EA2AAF
B6A9F5E540202B5F136DCD474D6C662AE3C7F11CB7A40D926E3CCDE38A87ECE9
657B806688FFCE2B10E27AE03F1E9DAD1207A2A85B3FB70C349E2627F7FE372C
F3174D8777E4985ABB10F116042460ACE945591284367CC3BB3D312CCB4999B6
F1BF5FA095E705954523C573ED0F0F10887A149C68CD0A16417DC30561FB66D8
42CC989C6F694ADBB064BB5E6E57CF11FDBE72381B2399EC7ADEF283A9B0D302
A1D969F69612A6AB78C6EA08E27A527B11AD2121249F117C7A56843B1E17B0B1
D1E0DA0DD6CCEA83C63D60F314FA826259C8C2167542D16FF3B46CE34669B38C
1F1EA068CFD585F1F90AFC2DA5A7C3ED9E08DE1F9926F5DC4E0FC422123185E7
AB7F6B6C8E1F33CFB724E4B3401541CE133B9F22DDA38D4F23489987C8FED499
D4456298A9865B4F0B47F21190977DE56A36DD665CFF0B117FC3B697036D25E0
E2103B98BB3787CEF2908A2797691BC01FBAF3E48850C048A870A866314CCBF0
F9C1FA776B54B67134242A353514B0726B1EBB53352EDB15886980C6690058C4
30F9EAF88DA2F1A54408D3836EEA6C5F00B8A5D2AC0063C86F266A2571A7E2AE
7C866962C0D6E7636F440A3B72F5BF141D73180C1915B757941DCA5D5B7CBA22
7E841314D6E7303EA9506BE3019D85633B4E87EFCF6D86C36FFD2CF9A0672D8A
9517FEF736A5093D81544D0C75AFE7894B7D9F65E035EAE63E6B9A205B37FAF7
4E76CAEFB2CA314FC615563CF3F4D1CCA8154703BCABA0EA88F62229C9ACACDC
03A56F203E46B94E0A13397C98604821E01F883E2387CCE3FD1A76EA4148CA9E
68BD8B49D45C39AB0C620CA7D12A86892AC441692A166F51180202F4EC3854B8
50FAD53B2CEFC495A0393D832FD8786DCD567772E50B23AFC76A54A611BF0708
7ECFB7488510CFB2C175428F1DE21520C338B48A6F4AC9EA487D4DBC690116F8
6F896BBC3E4120412AAC07BFAEB390811B0E628793F8DD8C4BEF8B088AF00799
06A59A9B27A74880B78B8637E50653985212DD45FE677027DF5C40B37465AA83
3476022E907300C2C72D3A485F5D38F1A7B21C8BE16748BD1702BC49AAEC6E07
B1BC1727D1DB053625AB8B3945DFA40AFF97A2018DCB532E7E8671A722C20037
C0C29D6E0E06DEF5E0AF6B987E9D36F97B9EC014A366124918507A2EACC31280
04C7F840EBB21B0BB11F81987310906055CE5BCCDF7C32880F7E2A0B40660E16
941DDBE36DE54CDE16DE96BDD88B14688C08AAE4938109B81E8794A83D3A2EB4
4A0BD8903FA386CC83FF7FE031FCC6F3C99DBD3DD961C713E8B6A395B55E82A6
4423927FEE493B050C22C86467E39C0E1B341A4BD614860B102CFA6379B767CD
355EBFA68A663B583F56187B048F80E29238B208F1F062EACE8A2D7DBC83CC80
218FA484AC546146A6DA52E5C8432255E6F4CBC3DCA58EF0691805817042878E
F3B77426C0A61E3D07F123DDADEBC0F4D8798ACDCE3106B0E722238AE0B0ACDA
EFBE54FA5AAE849219E77FD7650105F954DAC187B128DC3DDDFAC7C3494A4644
A647D090084D52FA14098E35ACA1BB77D98E658773AACB3D7FB0FA688384E32C
072833618C72F007500BEB9E3FB121E4AF6BAE5493E1F7C105252486AFDD8751
DD35C516605C354980D1F01307597B7985146464554C49A87E5D6C1E6BEDC1EA
3F575A376B5BE7EB71548429B8AB2E6FD6A1D5D02B254DAEE84886EFE5EFBEC7
7BD25B41952FAAE6D91BF1448CEDAD1C5336F06655A9EA3B23A094729DE9FFBC
51C659427D9AE9F3B5E6BFD4818475E1B32A9F9926AA17D9E4E6D9228C473641
4B1EAE8C048EDCB5922928A9C8212A808E1D039B8AEB42A0A2CBDABF6383EC04
011D88EE5ECE841B10ECBA60F37AA1EB1B375C5306D2CCE0BA2855A71955F05C
5CDF7515AF810EEFC1D9746E80DB8C6D1F1660CE961CAD132F9A194C5A5C331B
EE6569884A7DED0464C622EF317CB84590236ED09E4A2811494884EB156215B5
9F71D6FA34C119186C6C8E7BAEB668201C6E0D5A7904E5C03AFBE8B05BACA12F
ABB1F44A6AD6056EF703AB3A493D96813F4A685ED14953A35F57102DABFCCA77
0D8CEACDBCF4911AE0A6FB53BDD7463DC5E38A9BEC309A087F718947C99749A5
E6EC7CEE1B0BF87A7293CD3C778A826BEBC455FCA9D89C56824DC3B5FA1D29BA
10FA582302106DB094EA752F77981A5F15849F57EBD2BC97D65610D2F9FF2467
E24CF3B2C054C716F79C50C0C52F097ACD4E959C81A8E3D6DB21F728E19039F7
5B567634A64F8D416E96E20BC194
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark{restore}if
%%EndFont 
%%BeginFont: LucidaSans-Typewriter
%!PS-AdobeFont-1.1: LucidaSans-Typewriter 1.006
%%CreationDate: 1993 Dec 07 10:43:50
%%RevisionDate: 1998 Aug 11 09:45:12
% Bigelow & Holmes Inc. Pat. Des. 289,422
% Lucida is a registered trademark of Bigelow & Holmes Inc.
11 dict begin
/FontInfo 9 dict dup begin
/version (1.006) readonly def
/Notice (Copyright (c) 1991 Bigelow & Holmes and Y&Y, Inc. http://www.YandY.com All Rights Reserved.) readonly def
/FullName (Lucida Sans Typewriter) readonly def
/FamilyName (LucidaSansTypewriter) readonly def
/Weight (Medium) readonly def
/ItalicAngle 0 def
/isFixedPitch true def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/FontName /LucidaSans-Typewriter def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/Encoding StandardEncoding def
/FontBBox{-12 -205 618 928}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA052A014267B7904EB3C0D3BD0B83D891
016CA6CA4B712ADEB258FAAB9A130EE605E61F77FC1B738ABC7C51CD46EF8171
9098D5FEE67660E69A7AB91B58F29A4D79E57022F783EB0FBBB6D4F4EC35014F
D2DECBA99459A4C59DF0C6EBA150284454E707DC2100C15B76B4C19B84363758
469A6C558785B226332152109871A9883487DD7710949204DDCF837E6A8708B8
2BDBF16FBC7512FAA308A093FE5F093A8DD28A1105B8F1F45E83350E1A28A9FB
120979EB7214FB22705850743580927667FFE0A7F79B201CE22DE069A46E69CE
07EF71A03D0719532050C8E023D2D3B0BC64AB04C9048B447134BA084A29DE31
AA6C3E58684B266860B1428F95F838E5E279C2EE9D6C8BD836B1554C2B17A1FB
3431BFCD994A9900889B090388203BB5EB869ECD8E5374B724D279E941796B51
2B9A129F690746109B89666D1C4DC0594C07C7BA3A993BD85F63CDB6911C7173
D4BC2B5372FE9DF6F902A1AF01F36C4E12A93A5E8E781BCEC47D70E12A13D9DD
E203E7344655838AB5D9E0332A2F41E29140361904C0103B5C1CC6CD9185F359
9166A1D59404EE64C441F412802C79896447F0CAFCECBA339A7918DAF195EC11
5ECA390C6E6BE029A13DCBB49148B21B6675BF9BBC168669BAA4EB9A6C0826DE
476186CEC9462EB3C1C34F4BD2C3DE28426FE84C3747D3894735856D585C7565
3493F792593C9F2DF043842CA4B7334F101019DE241FFDAB47BB7AD92208F155
9E173E7AB4B4B20A31FE1934CA70C680AED8E7621C8AE143CE86C70A831B6811
D838290481144F47547D034A893A55A70ADD53FFB9184E32504C988DB7B866EF
D978A8BEF2D95B7284325DA96DC5EC4CDC72BE1FF19A64C20F06ADC0511C2DEE
D173897B9CC85E2797C5FAC9BABBEEBA98AD92AFB248FA68493462A254182C4D
74C6015B2E051A6C01EAA64D5BB8AFE4FBAEC50F70C945AAF733C7B0F7166237
0BF63C246E94023837575D02BEC675BB4B5754D6A9D26140BA17197CD4A6FF4E
01A45898DD0F2BE9148FD403D181CF3B498F8F696E6146D2E5511ACA11F04D70
E268F1D4B5DE04B45FD7B2D6290324B1C341427D0A4107DD587499B7A4B09E56
92F323BC687A2F4EA3B19D7E909D7E57B80AD9F00D0CC3D3B7A1ECFC649A6142
11EBEBA3D0A82B2003DA541162672A62617B5C7D69D73B3D107D4E9FF30796CA
DE8F0C39DF8F351E153B539BF8237387D56F9CAEC0D5C3C68A433198010C94B8
8ABB8D8D08262725A0904BCB5EA7C17A39552A1F26283F54A8AA17D716B28286
06C553F92C65BC84B42D8361F4F4AAC58F6CA8228F29E7E73BC9CA5E20B1B2C5
ACB704C5AB8E84B4BB49A972F49D260EF7A5A6763155E7FF5DB75C1A20FC3A54
B30B97E23CD3030B8255F7C59FCD30333A29536DCB1FFE24A9224B08CF14E591
7061FEDF22A5CA189508F1C6E52F1D15141F83FFE6AAE18CC0C8944004642195
78846685909845C2A0B9924D7BC3394593C5B714D11C02CC38D1DD42E3743CD9
89FF2F781D1E47C6309659B02050118CBD931E99A7EA9CF38D4DC9CEF2618FDD
A774EBDBE7A95014ED450627C39C2D01215CEDDAE51158AF491169D7FDCAC504
4E1EB97149F9616B2BE2C332D736A277AD129893E668AB6E56729EBD42E0590F
3089B1CCB31958BE05D50483317505A8B7891E5023062BFA55918CA493180E5D
EFCCF303FC7994638F0F14DB3C180F84CFCACA59F16FCEC9F8C1BEAA555F7D56
544EEFEBF1D3F3CCDC189380F5A35DE65E45B0135F710FE5A044AB0E8D7E3E68
73CD7F574245CB42154B3241037B8AA1DB2A52AB99BBA392E127C63CD8959D9A
65EF45AEE10546E33593CB959BFA693C5E3296F653357D5368782DA29016C87D
70824346621EF420E7F2982C73F8942122D709569A92AFFF54C0ACD377489056
3561F6EB92307AC314EBA480C184AD8F07CD7C6689E3A8B78AF75972140DA275
C25E80658F5864CFC3C4B17778DCFC0217DDB3A85A0A284B863AC79188F0E884
2F590B0085CFCB984961F1CD5EDA44A2417FC94C3F69B34ECA68F8B27F929DA6
23BD36780349A3383193FA419DB7587DB5F5922047941C76D585FD8A324639A4
99E137A5A092F17D358DCB42CE0BE35F8144E2002A8954BD5B13DD4572D53EB1
9881B664DE528A57110A96B88325D8B21EDD46E771AB9D6FAC3A27E55198D0EE
516FA4D2E555C2E1E24231224B4ACEA3B8CFC9140FFEBDE5DBF52B698D593F36
4EF5244E5C2ECDB3C7CF828FE728E6F4C99DDCB5BA5FEEA87AAE2B9120E5AA44
4F64A64A0E6703534E93E08D96B612BF0C2ABE3A90DDEC4DD57D22D23B16F7A8
243FC9CB2229D5B0142C50820744E06EF35A656F243E44E6D85747365B2ACEC1
7BC0FF1579B936B58E4DA0E7332E8D2A3403C9C0DBA6785D535BEF2E6F53BA13
CADA440506513B9DB5F7344BB7D0DF0A1DE792CF53A1F7EA532AA8F26AB1F77B
FC0AE724678F69DF20A093BBBAD9C03510CF28BF2ACB640167F539509184350E
C343C85483662486008F30C8136AE86E9BC61E9C1FE4523E7319D0A1459D4AF4
CA3E25ABEE3FF84898D2AD8C05632CB2DAB23060C8897B8EBAD04E05797C4119
7F77ECC27DDFB51EC441AD9B81C081229AFD69BF599FC83F56F85621AC7DF5E2
49AF73118C9823A693F5A90CE04C91F3F45E3A14562065620BE6E77AC7F78950
20BC2F46A2412DF008F552DEE49A701AE8572A7DD638B5DC7DC5D627FF9D5CC2
75A64EE8695B96B49130909A70334FBC6C9C897AC8CC1631E2E0F61902132F2D
ECE8905A29E776978DACE10B6AD982CA4C80F4DC6ED8AABB58003444F93682EE
2F1FE8AFE0670DF5E4BC47D6A687951B22215259897FA61021ED425F565D92C4
F614377CF4D5037FA2283AAC577783EE72BCD98BCB05F01560F6DA2A6F087163
C374A355BDA461F252CB9ED18195F08B051E9EF5AAA28F777E4B38F62EF56EEC
3EE18494D13A029420CB695539D43C062F396D9CBBD1AA80E2362280A0F91AEC
3A1E5D5E2FEF17B65265C9A76680CFA3A67D589C574FA31FD4122A54124C19BA
D8B0AE29EF4B873111C519537C11F8E32A0DE7F1B00C0C5434ABEADCF1323766
9F1DADA849333F1DDAFCA7FAC202D9355F924C856231FE5DA6FC520202CF4D1D
F2047A7B2E9AB3BD3FCE1504892B17EF92053C4E7C1E1790D9FC2341291F1139
A23D6AEEFF1023A3D84E29BFA4D11F5F79BB7E9BCCF3D1B9C0498C448C9D873C
45060B78BF529CB5F5F4324540C415147AF4EDC20504B77FCA9B275215D6B710
5A14F6355EE890914DF8EAEFFD592BCAFE306B7401AA39AA61A760448D037AA5
318C90F8EC19FD29C47B622E863C651A0054BDA26E4A14C0E6DE8DE3FBD5E295
C59B4F4538075C8BB2347E6619D0FDB77CC23C3DA462621C2348A7C611D6F521
07D132189931FB8BA438606FA02B732C1649706F5BDFED4AC10C607F4240135E
AAA9237C12F92559BA3F0D48F2EFEF55B620932D1B397A8F565D1F9145C81348
7B06D15C33162AC05B9D7D2B7F5115538972801845639CD4B53953B33D1AC75B
15345DBE9977CD34F786C80D8826B7C68473EEFCC107238DE011B0A08BEB5CDC
F3472CD3619146BFE3029848E69DD2A3ABFEC7612E15059A6BD6808FDD27FE78
706C3D705A8D5543DA4787059081A6A585A023EEA94A804E8BFB6DC285BFFC4A
759B6AADEC57A2E38D6A681D7DFEAE21ABAC15D147F15C61AD76623A26225973
3B3344B3C18FE43DC600BD480CBA8CAF9126E3612B0389F3618CDC776C1A674F
AE69FF7C2EF73A5D6EA1F965E0928650FE30A83A15C00091182783623694A93F
392546669D87BFF1E19531A0A4DA1CE63A550BA4268110A665BA7B4091B85A2C
F846EE895ED1D2D40F6E0173A1F092DFC8DC7C0D7F506660715142C26D8D8BC8
7CA02556A50D18B642A4419844D92E160D53481B097B43E196153EAED66E59E2
575E6EA8817D4A3BEAB6276E21F36104C234C84ADD48BCAF0C16C583431535BC
379BF175AD135A368144BFFA48618A0B734DD5BCCAB37F9EF75CC006E0CFB735
84EB71D0ECF2E74C10AD6C6980CDD73AFF6402879FA59D6444D7C57A5AF99BE4
E19B0AC28C5518130C71CC70E85259C43AFE47F482E880F3D982D02298742764
01CFA264455E90C789303DB5587BB836EF15909A1BDC9077F70F2BABD919636A
F8239D454135EFF2B9C4FE20F19AD1CDA32B4C4F709FDA6EB7885C9BFB606366
6855A5C672AD6C37B3C03E932C5284A0E87C77EF00A6A494F034F6D97DC28D94
F3F277A02BE0CC2C08EB092D1B42F3AD513A10F8DBA26EEA6E6060E80D52B199
D3DAE4428BA8B60D429A8080
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: LucidaBright-Demi
%!PS-AdobeFont-1.1: LucidaBright-Demi 1.010
%%CreationDate: 1993 Aug 11 14:19:39
%%RevisionDate: 1998 Aug 11 09:45:12
% Lucida is a registered trademark of Bigelow & Holmes Inc.
% Bigelow & Holmes Inc. Pat. Des. 289,421
11 dict begin
/FontInfo 9 dict dup begin
/version (1.010) readonly def
/Notice (Copyright (c) 1991, 1992 Bigelow & Holmes and Y&Y, Inc. http://www.YandY.com All Rights Reserved.) readonly def
/FullName (Lucida Bright Demibold) readonly def
/FamilyName (LucidaBright) readonly def
/Weight (DemiBold) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/FontName /LucidaBright-Demi def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/Encoding StandardEncoding def
/FontBBox{-287 -205 1122 928}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA052A014267B7904EB3C0D3BD0B83D891
016CA6CA4B712ADEB258FAAB9A130EE605E61F77FC1B738ABC7C51CD46EF8171
9098D5FEE67660E69A7AB91B58F29A4D79E57022F783EB0FBBB6D4F4EC35014F
D2DECBA99459A4C59DF0C6EBA150284454E707DC2100C15B76B4C19B84363758
469A6C558785B226332152109871A9883487DD7710949204DDCF837E6A8708B8
2BDBF16FBC7512FAA308A093FE5F093A8DD28A1105B8F1F45E83350E1C85FB4B
8E0949C46537E67A9D92EE02E5724E15F8F3B3E93C8F35B871FFEA1B4DB0DB19
B21866F8DFDF2DCFA70C3B351F8279D762826688E0BAA2A93A97B39FD3DC894E
BE465409060FB4A755BCB74CCF9250ED2CFC57DCF3888B1DF55F1E8FCB6AA441
B3006FB7A4CE515E6EE633C9C492186870A0935E897EA3CB3F072F9B78FD4BF0
A8D1466FA5EA1CB4D188F300EC0C49B3F67B0B7F39290107FE36BD36A6DC32B9
E774FDD17523E7AEDA9B664CC8FFC808F3450F244B6D2ED304C838A9CD353F30
11BB4F0EE55209B464ACBB3501EE7348661D12C5846573444207293BB2B16730
719E5CAE448461186329331A717AF04574C8F1D8F3F26C2B575B6C182E390E00
8817A70D21F5DA3ADB0EEAA86FD793068922723A28DC27060F79E34533749F85
AB9F381CBB865FB8A641BBBD0924B947734C73FD7AC576C17638941885EE92BF
3C0D2B8F5374F36FA27FF568D6DF65D2DD3FC9D67268B6551AB2E4EA58BE1E93
E6E016233E7D4E8D54A47418CF91DE34178FDC9666D9EFC7D0E1E7FBF2742CDD
ECBE888F47B4C192212D8E1E058A2DC36A19A900C20BCDC50E8712A8ED3E6D23
CEC6F81C987F54CE4F7174F6C4D80055F87B980427CA2095E2D236055D8D4F24
A5AF8C162D8C5D0918889614FEB7A2D51EE4BDB9E6E9840FE2D8A1F8B975B64B
76766095B00B3BBB75DBEE08A7E5877208A658006E6AD382239E2AAB88824048
5B0A6E4018FB03C530C2DB257C42BDF8F4324B6D4F8117D51896E73ADCF88131
996F6B19CB8FEFCBC7FC09F9FDB1F478E3990DF27DDD98272660643BA5293F09
EA311F49295304D67B63178154B496940A35962879E04DC0D6283698A574592C
951B42EA7469609F072D384661B2F06F856541DAF493CECD10A54A3281F18C95
43719F90217B8FADECBD0A0255ABDEB555EE5EA7AD4D7782A8387E49B8F4641A
F333A71119C04E7C670E03482CC063B75149A74D1489DFD974588112D4CB6303
89A4F601F288DC3A55C75248E4DB744F6E0C54E83C14066C3443BB3AD6DC4CF0
05D393672AF65F0D015C86E975DA613B1A7BF337DA8B9939021638949FB0039D
A5F622FC4100B2ED4E790A79B996D7C775A472FC1F39ABD4BDEA1D5AD143A5E8
6CB8B7FFA77448B48C85E46121067F55360E3E2A83100A7477F0591A23CFC73E
FC3F8B29E27BED418F2926E3496E3DD9C4C65867FE27A3706B63E838D767065B
E62A4C6637A0FCB6836AAAC07E50D024D45A9A51D740B3A96E7AB386AB4E1154
350DFD382B371DA1EBCC42F52683F8F49270A5065C793517EE94E6FDB094D882
E2C716E592FB4DAB538C280A8164E79E8841E7080BFEE466A1D97C63750404EC
5E3A3F07070905E0622558353F91315BFDCEEA44345BB1F938A561CDF4FDB94A
ECC50946E35C24843A7B62D21FC003739276995E30218C8E845A418D697A3875
96180740D0CEB6C5B14CFFDBC5AE92C777114569740FBB5BED1DE0646F56F9C7
FD6AABBE605A4785AEDB5A295F77C7F3597665D53F539E269F431CBC87F668E9
9B42621C2C212F7FBC125CD7E22B34A5E2E9064C6443F42ABD28940932FEFDDD
1A0EB7BB9A900DEBB6211CE3C17EE39CBDF02CC4DB937D6D65EDCEC72E05BE70
6BE6BBF540B73C9268FBB2ECDC51608951A6720E2C11C10F3C61A201262D85E0
479B51BAE5B57A30844CDFEA6506CD5686D98B39AB7430B63CF0AA378B53F687
F703558DAE23665B1FD2DADF6013E01082F9D8123A4AC2F36BE4210E0AB3B21F
2EAA800EBFA9C86AD6D937F0C76DA62C7C44A8456C90D18E5663632646CC97FD
BFBB1AC537877E4FB07EEE6EEF5803B850BE68193F5E23E31CACB91A692CCB05
2937052B6DAB8C02FBBFAE92983B396478CDA35BC3F1E4B5686D6A10AC0E8CF0
DEA7DA19881B7402A86FC94651A5F857CA4C4A88CC3673E1CBDA35F3E0A293F6
B321287A6CE2DB2F6ECBA45FABD9550C187F17A987C761F8B61F42CFA8CB1A4F
90D21ED4DC9E5CC0512C9C3F7AE1A3858110044549CF53648510388D1BE1DE71
BB00FD82A0B7EA1F6B653685213207D10B85D19D578718D637AD0BA43F25AA0D
EB5235E70EF63788154D9A74857C7730449E1984B04EDAE8B1EE0DE1E4EF7BE1
3D95DD16C898748C1D026197BF5DE48A607A46D2B8EC4CE738C2135F89745E15
A6815F9DCCBB0341A60D255609C293876FC0CF3CAF1CD0400E4AE09D44DD72DA
7D50680F1D903957F2FDF4A84F96CD019F9C02775BE06FE300093652D986941C
7B1B9FC7BED14BB903EC66BE875F2FED6D8C0C6CA0657270010ED6BE2A5A1B55
19E85D2EE252D3F04655CBFDA4566BC870528C4FD8940971FEA8DF73B718FB94
45722C3B50DCB437DF6E518BF765B66B1E674E79A8D053D902A94AD5A3EE7570
03F14EFEEDC96845A7D73A8C48CCA72DFF86EEEAB106ACAB24B88CAB8036938B
55DA649EC8E5B332A532423F9E1F4E57C6F2EAE2E28DA245CF5A9E7909D36114
DD6004726643092F42A67EE784C1AC964AC3DBA158DBF8F477F6E757E1AF2574
1872DC4238FA1C1B8059EB4B11BB65CEA4CBF519CD4D1EA7DD7F08DEC1B25535
99AB9825918728B868B3AA59D66F52396DC8366EF0658444A03E10EDAABDE7CA
00B18B226FB7B22C78454297C7BB3F5BCBF2412175AA1C4FDF7E79C70FB1214D
6A9C084BAE2DFA603DE0BEC4EA38F08B3A9CBD30E81B98B528A087DFA19EF923
237465D8696CF8F5BAF6DA8989774ACFD442A06B9BFFA4D0C10F163838C2BF01
30E8EA2AB8F95AB54E2C062C7546A3227931C1FE2C22D41AE7EF9365E29ECCAC
34C2711A70D9C4921940795D7BC356146971EB2CCB636B4D512028B138AC87CA
21015749FEE7BCBAE79E96A3B25B6EA6B32AA0CB3C522EAFDCB5EC4D3518092C
3329DDA6019F58908E9C3813BE1EFEDD7A9E9862D01F7BB852E308B42F72B5A2
CD4DF2A05ABF7CDE6977DB56950FAB75D47F9EDFD5644F56D09DDA5F61F93969
978E007A8FC7FED44A4E85D27691E651E981FE647D03707515460A6A9760A39E
4D26EC05ED435B5742B9BBE1B00B630C49BE768178462BA6C8E1E0030D9B08E4
D94ED908816740A02EEB4F43290E43D895488B80D5D4B0EC2502DF618406C788
D458FD6E3BB082203B6250D255E3550CAB2937EB8912FA88CB9B7EEEEED5AD05
206BD9533D607EFD797CC41B64C6E2273CBBEBBF8FA50F2523F5AD2499F49174
1C203BD16325744724512D4F2BC2618DD3F109D9C52AAEDA5EE9E4AB406DC1F2
015A90C5DC9DF127E900F604D5A22DDD6FED2ECC93CE5396EDB54D49987E6094
24E48CC4691B4B422C873ABC84A4F5900D98811EF530D3A23F8E8F30E0BD5A1E
2C6F3EC2243BFECF17867643B0227A66C525C0A3842B6FB5466B158636F5AF7C
0340EAC929330C4C37C4E6A8B1A2C66CA1D91578D4FEB5DFCD1564E483B4CB34
D8EE38B95D2F4FB183433141A02993E1E795C5EC45DC68CEC9DC4133FBBBEC2F
D3E050C82C60D87E85B67B8E8F59A14395AA88975D64961D40E9BA2EF074FB60
3D188643B8CEBDDF4C3B30D674A1AEB6C8C3E0B256135CC77B3A4CDC0A1E9F19
1300C3FFB4672D49F46405FA7B1743A48B6B055CBEA3ACFE3470FAF423F7F609
CBD6B8D13C6575DFA932C6C2E33A3CA1E6F468A97B008AAFBFBE7F59D33746FF
FC8B7A641617CAEF381F98A64077C74D0A750615E657159D60D27EFDD672359F
ACAF24C997895E85DA91A46E2C2A93FC5BE6587C65454BC3200CFE3BFE4E6703
D8885066337A1C325FFFE0DFA71606F619099305ABDA093EBB1FEDB040C5A57F
55DC3762A4FA0718BBE91EC9B75AF8CF4DA692A2F3C608DE81EA453AEC156768
A95035AA131552247AD8D85DBA90F7CAE0476D1BBDD76CEB8D1EF7402976457B
0816F9F4E2955E9254DF57372F057ECD00EE79B05F8EAE210F0E3319A0EBF1CD
7B6CDE6FFDE272592990EC2CEC4A54F18CFB2DE2E347BB274369FB86A36F4E47
0082DEA5D88D4F05D023081F678CFE58E7D9AFF5343BF2A456C42FD15EF7899F
1B2DE6186C5F08DAF34F5EAE33FD7097CED52050007FFB75CC78DFD646A8DAD3
508F9BF37A8BDF68425A881A239D203CCC7640C505C32438B21BFECABC304B25
BE59939BEB9CC5A8F3F8AA5A18B2A8C1E8EF9FCBAFF5CF80B7458E4EC14E9C6E
78C9EBE8FEA91B5C95AE0EC12A0F552C48C519B5BE339877DCF7697BCFB86ED5
76C66E6A6DD54F4C7DAA5834443D63B2F1DB15F6EE40544BB4A0187EA177F934
F930B7239828D849D12B8C973435C3DDAA8FCB41B1F9EADC6BC71F9E8C6648B8
59D6D91E295A36E58D2E17C703B754699983F371F605BFC462EFD8A7079538A5
63A00B1E3DEE28B7287861800F9CECEFC39919927337E9ECACA8D7D9829B2591
D8B6754F7A02C6715587CEC78FD539ACB8A9EB92DF6B4F55321F31A914B8808E
6DC0C43C7C18CA5AEA0E71142522022F51862EDA124274B375B4631F8E32D8E4
FD799590D4ED552209C80F5C59EB3F9EDD58EA2C18CDB0A90323013932ABAA9A
D8C95D1DCDC6704F26D995F20B2F2CB111E2023A4F5522CFE857699A4123733E
B3BFE28D3324575C95E27F4B0484A504C16EFA8357EB6C414CE5875128361B40
0C0F175A2D16AE1FF8DFC7FD672CC0E8B07D5327A084F9BC0CABE0598A9C3DD7
1A23F408D23839C9B46B3217BE6F20452106B9BFB35DB0DB657D0C0F463C0DD7
8D62E30396D1CBF5149219C4058E0DD6F6E1CDCE7D8742502490DC51084B4610
D578B52B7B382FE9052A9F0555C9EB64ADF49118B7CF472FE10D04343E0C4853
E720286B6F14AF5BE28FD1672FF0D4D8F7267DF57DC25AFAEA9603BFB4A339F8
A6194C93F304A4F9876741D0406E95B7FD97DD5F0AC41AE3629E73376D2F261E
1B954283552E4BE25A727B74C96DB2C59145192010D323B1F56E4DF96E778914
C8C4B20D9A15DB9B6E55D41463CD63689382AD45D837013501D46BA94B3F63FD
0DEE315187EEAFBF661F20F5A2442ABA5CBF6935D8640B9BF636AA116AAAF266
34BA0762789E2317B7D5CDCF42F9B15878414EC5EF166A28EF47556ABED44624
79C435F19F515251ED6F25CFF52848ACD7A2AC757440BAE2B2115ADC297679EB
67EF99585457C8078A708ED35AEB86C15730BF3A7AAA4229AD4EE31DB46E232C
239405078097D02AB9A1FB97EE6D6F2500498B9CCD8A87DD759A6E34281ECDAF
03734790C3F6323EA7E3AB0A4695249E89B7DB7E3A6BD87914A5341B2172C116
3F97187141F671DE835DE1378576DE25A0424EEAEAB30528C4352DF96840E3EF
8D111B7C1355CA7C01BC6E96FC7781DDA4FA11D2246EE4505C8EE0D8AC6BE84D
D8AEEA27B133227E9BCE7CBD112C8592B57BB913EF8FCD54366DD5CCC3019E46
3CD6ACA285B846A46DF25C7DB1284A344130194379F4337A437F91569758E0D7
5F79D6153ACB451C8DAFEAA357B8AF8F1722CBC5DCCBECEC5B1CF3CC81D6F153
DBA3B35D5A55E149C1F9048C0BEE5853B5FDF77CF3041D26706A750A2B5150B3
72728B82EB0AA9DC21A4265EFB0164794AA7B4DDEFC9441D57E9231CC57F0654
A83F5F8969F1949ADAAE297140C3E59D0E975E6DB23560E9B9B5671FD8666C4B
878D898D38E34BECFC49C52E85A66D0F6197FF037B9F8420165210CE849337FB
AD86B5C4E461E54E2F46625B99B942269FB8152FC5B83E606E150102EDCD1264
6DE7D701997C93BC5DD8CB90D6D2CB99013894AF6730184B7FD52274D77CE6FD
27F168A18C760721D551AD127BA78F97EBA581E132537C660630BA9A5E88BC8F
3A09C83DB706A9C6991B1BDF819934B221375B29460C5C9B1E8D26F7B4DAD37A
B4145854461DBF7F1B33E22C24DE1810BB9421049C54FEBE01002DB9ECAB218A
46AE61F223ADA791441580F70A7ACC31B3D4BB832F703F70F37AE1DE21FCAA0E
559D346B48BD079EE0444039269A8B0EF29F611B66866465D98E7868E218BADA
39FB04FFDC5378514A552D2ED6806D9C0CEEC67D9EC3A5B288575522B5B8DED1
52BCBA9C275F5DC2956325BC0BAEC3D55EFB11B4F6F23184C9073A3D424B4798
CC3D7EA0D06E14E4E02E59C176A53EC7E8AA66A78B3E723673F6188806D65A31
CF67C6A5630267A7476A6154FF59666072150C2E7CE801590E697FB3F683805F
BEF78422057AC1C94F05AA5BECB9AF69B9C1B9757BD631983747B985AD3D4A39
753505BAD1C6721584BA0D2F6F0F04672A9BBFBA5C7EF4DB44267D7BA0EC0871
80B72061CEF1D21F3B1986D3C5706158C11E0CC785B7383D902896B2F3A2FCDA
A2017A2323F2BFB06C80035743E4FE19A4B070B9D3894F432425D1EFE33E6112
B9B7E66E16971E73EA04A387885B602CC8FFD866DB3CC1E5492F176EA0D2E90E
011AE6438C4B5A540D6CC434D550CDA2641B9F5C850C08FD9FAC9CF43BAED59E
6DC927C793826DEF390F626E5FD6C154359A41FF90E4ACFC
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
TeXDict begin 40258437 52099154 1000 600 600 (wieesgeht.dvi)
@start /Fa 135[38 3[27 1[30 2[41 43 64 21 41 1[21 43
39 1[36 44 1[42 37 16[39 6[22 6[41 21[18 2[21 21 40[{}21
67.9953 /LucidaBrightCE rf /Fb 139[45 45 45 1[45 45 5[45
45 45 3[45 12[45 2[45 2[45 6[45 2[45 1[45 68[{
TeXBase1Encoding ReEncodeFont}15 74.7193 /LucidaSans-Typewriter
rf /Fc 27[41 105[45 41 3[47 29 38 33 1[48 45 47 71 23
45 1[23 47 43 30 40 48 1[46 41 6[47 1[49 1[52 1[50 40
2[43 2[64 1[53 1[24 58 1[41 42 57 52 46 56 13[45 1[45
2[20 24 20 2[24 24 40[{}44 74.7193 /LucidaBrightCE rf
/Fd 141[41 1[57 54 1[85 28 2[28 2[36 49 57 11[62 3[63
14[53 1[62 21[25 45[{TeXBase1Encoding ReEncodeFont}14
87.6717 /LucidaBright-Demi rf /Fe 190[43 65[{
TeXBase1Encoding ReEncodeFont}1 54.6286 /LucidaBright-Demi
rf /Ff 135[45 2[49 29 7[24 6[42 12[52 3[53 2[61 4[44
6[45 69[{TeXBase1Encoding ReEncodeFont}10 74.7193 /LucidaBright-Demi
rf end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
 end
%%EndSetup
TeXDict begin 1 0 bop 0 0 0 1 TeXcolorcmyk Black 0 0 0 1
TeXcolorcmyk 1677 577 a
 tx@Dict begin tx@NodeDict begin {10.79294 6.21198 91.44824 45.72412
2.29048 } false /N@A 16 {InitRnode } NewNode end  end
 1677 577 a 32 w @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW TeXDict begin XC@black end  0.4
true 3.8 neg 6.21198 neg 87.64824 10.79294 .5 Frame  gsave 3.0 -45.
PtoC Shadow 0 0 0 0.4  setcmykcolor gsave fill grestore stroke grestore
gsave 0 0.1656 0.584 0.116  setcmykcolor gsave fill grestore stroke
grestore gsave 0 0.1656 0.584 0.116  setcmykcolor  1. .setopacityalpha
 fill  grestore gsave 0.8 SLW TeXDict begin XC@black end  1. .setopacityalpha
 0  setlinecap stroke  grestore end
 
@endspecial 74 w Ff(L)1800 564 y Fe(A)1832
577 y Ff(T)1873 597 y(E)1909 577 y(X)23 b(Quelltext)1594
935 y
 tx@Dict begin tx@NodeDict begin {13.80516 8.4301 111.32481 55.6624
2.68753 } false /N@B 16 {InitRnode } NewNode end  end
 1594 935 a 47 w @beginspecial @setspecial
  tx@Dict begin STP newpath 2.6 SLW TeXDict begin XC@black end  0.
true 5.6 neg 8.4301 neg 105.72481 13.80516 .5 Frame  gsave 3.0 -45.
PtoC Shadow 0 0 0 0.4  setcmykcolor gsave fill grestore stroke grestore
gsave 0 0 0.3 0  setcmykcolor gsave fill grestore stroke grestore gsave
0 0 0.3 0  setcmykcolor  1. .setopacityalpha  fill  grestore gsave
2.6 SLW TeXDict begin XC@black end  1. .setopacityalpha  0  setlinecap
stroke  grestore gsave 1.0 SLW TeXDict begin XC@white end stroke grestore
 end
 
@endspecial
45 w Fd(pdfT)1884 958 y(E)1927 935 y(X-Compiler)875 2684
y
 tx@Dict begin gsave STV newpath 0.8 SLW TeXDict begin XC@black end
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow  } def  /NCLW CLW
def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@A /N@B InitNC { NCLine
 } if end  gsave 0.8 SLW TeXDict begin XC@black end  1. .setopacityalpha
 0  setlinecap stroke  grestore  grestore end
 875 2684 a 2794 700 a
 tx@Dict begin tx@NodeDict begin {18.61697 12.98303 78.42354 39.21176
2.81697 } false /N@C 16 {InitRnode } NewNode end  end
 2794 700 a 32 w @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW TeXDict begin XC@black end  0.4
true 3.8 neg 12.98303 neg 74.62354 18.61697 .5 Frame  gsave 3.0 -45.
PtoC Shadow 0 0 0 0.4  setcmykcolor gsave fill grestore stroke grestore
gsave 0 0.0621 0.219 0.0435  setcmykcolor gsave fill grestore stroke
grestore gsave 0 0.0621 0.219 0.0435  setcmykcolor  1. .setopacityalpha
 fill  grestore gsave 0.8 SLW TeXDict begin XC@black end  1. .setopacityalpha
 0  setlinecap stroke  grestore end
 
@endspecial 2875 646 a Fc(Klassendatei)2875
746 y(Zusatzpakete)875 2684 y
 tx@Dict begin gsave STV newpath 0.8 SLW TeXDict begin XC@black end
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow  } def  /NCLW CLW
def tx@NodeDict begin 0.0 -5.0 neg 0.0 0.0 0 0 /N@C /N@B InitNC { tx@Dict
begin /Lineto /lineto load def false 0  setlinejoin pop end /AngleA
-90. def /AngleB 0. def /ArmA 10.0 def /ArmB 10.0 def /ArmTypeA 0 def
/ArmTypeB 0 def NCAngle  } if end  gsave 0.8 SLW TeXDict begin XC@black
end  1. .setopacityalpha  0  setlinecap stroke  grestore  grestore
end
 875 2684 a 567 700 a
 tx@Dict begin tx@NodeDict begin {18.61697 12.98303 102.87631 51.43816
2.81697 } false /N@D 16 {InitRnode } NewNode end  end
 567
700 a 31 w @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW TeXDict begin XC@black end  0.4
true 3.8 neg 12.98303 neg 99.07631 18.61697 .5 Frame  gsave 3.0 -45.
PtoC Shadow 0 0 0 0.4  setcmykcolor gsave fill grestore stroke grestore
gsave 0 0.0621 0.219 0.0435  setcmykcolor gsave fill grestore stroke
grestore gsave 0 0.0621 0.219 0.0435  setcmykcolor  1. .setopacityalpha
 fill  grestore gsave 0.8 SLW TeXDict begin XC@black end  1. .setopacityalpha
 0  setlinecap stroke  grestore end
 
@endspecial 648
646 a Fc(bin\344re)e(Formatdatei)648 746 y(Fonts)i(\(Metriken\))875
2684 y
 tx@Dict begin gsave STV newpath 0.8 SLW TeXDict begin XC@black end
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow  } def  /NCLW CLW
def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@D /N@B InitNC { tx@Dict
begin /Lineto /lineto load def false 0  setlinejoin pop end /AngleA
-90. def /AngleB 180. def /ArmA 10.0 def /ArmB 10.0 def /ArmTypeA 0
def /ArmTypeB 0 def NCAngle  } if end  gsave 0.8 SLW TeXDict begin
XC@black end  1. .setopacityalpha  0  setlinecap stroke  grestore 
grestore end
 875 2684 a 1480 1283 a
 tx@Dict begin tx@NodeDict begin {15.8 11.8 53.63864 26.81932 2.0 }
false /N@E 16 {InitRnode } NewNode end  end
 1480 1283 a 31 w @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW TeXDict begin XC@black end  0.4
true 3.8 neg 11.8 neg 49.83864 15.8 .5 Frame  gsave 3.0 -45. PtoC Shadow
0 0 0 0.4  setcmykcolor gsave fill grestore stroke grestore gsave 0
0 0.3 0  setcmykcolor gsave fill grestore stroke grestore gsave 0 0
0.3 0  setcmykcolor  1. .setopacityalpha  fill  grestore gsave 0.8
SLW TeXDict begin XC@black end  1. .setopacityalpha  0  setlinecap
stroke  grestore end
 
@endspecial 17 w Fb(DVI)p Fc(-Datei)875
2684 y
 tx@Dict begin gsave STV newpath 0.8 SLW TeXDict begin XC@black end
 /ArrowA { BeginArrow 1.  1.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha
 Arrow  EndArrow  moveto } def /ArrowB { } def  /NCLW CLW def tx@NodeDict
begin 0.0 42.8 neg 0.0 0.0 0 0 /N@E /N@B InitNC { tx@Dict begin /Lineto
/lineto load def false 0  setlinejoin pop end /AngleA 90. def /AngleB
-90. def /ArmA 10.0 def /ArmB 10.0 def /ArmTypeA 0 def /ArmTypeB 0
def NCAngle  } if end  gsave 0.8 SLW TeXDict begin XC@black end  1.
.setopacityalpha  0  setlinecap stroke  grestore  grestore end
 875 2684 a 2320 1283 a
 tx@Dict begin tx@NodeDict begin {15.8 11.8 64.47456 32.23727 2.0 }
false /N@F 16 {InitRnode } NewNode end  end
 2320 1283 a 32 w @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW TeXDict begin XC@black end  0.4
true 3.8 neg 11.8 neg 60.67456 15.8 .5 Frame  gsave 3.0 -45. PtoC Shadow
0 0 0 0.4  setcmykcolor gsave fill grestore stroke grestore gsave 0
0 0.3 0  setcmykcolor gsave fill grestore stroke grestore gsave 0 0
0.3 0  setcmykcolor  1. .setopacityalpha  fill  grestore gsave 0.8
SLW TeXDict begin XC@black end  1. .setopacityalpha  0  setlinecap
stroke  grestore end
 
@endspecial 17 w Fc(Hilfsdateien)875 2684
y @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW TeXDict begin XC@black end  /ArrowA
{ moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4 1.4 1.5
2.   1. .setopacityalpha  Arrow  EndArrow  } def  [ 184.94283 184.08928
184.94283 202.01465   /Lineto /lineto load def false 0  setlinejoin
Line  gsave 0.8 SLW TeXDict begin XC@black end  1. .setopacityalpha
 0  setlinecap stroke  grestore end
 
@endspecial 875 2684 a
 tx@Dict begin gsave STV newpath 0.8 SLW TeXDict begin XC@black end
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow  } def  /NCLW CLW
def tx@NodeDict begin -20.0 5.0 neg 0.0 0.0 0 0 /N@F /N@B InitNC {
tx@Dict begin /Lineto /lineto load def false 0  setlinejoin pop end
/AngleA 90. def /AngleB 0. def /ArmA 10.0 def /ArmB 10.0 def /ArmTypeA
0 def /ArmTypeB 0 def NCAngle  } if end  gsave 0.8 SLW TeXDict begin
XC@black end  1. .setopacityalpha  0  setlinecap stroke  grestore 
grestore end
 875
2684 a 2951 1286 a
 tx@Dict begin tx@NodeDict begin {16.36348 11.8 97.46252 48.73126 2.28174
} false /N@G 16 {InitRnode } NewNode end  end
 2951 1286 a 32 w @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW TeXDict begin XC@black end  0.
true 3.8 neg 11.8 neg 93.66252 16.36348 .5 Frame  gsave 3.0 -45. PtoC
Shadow 0 0 0 0.4  setcmykcolor gsave fill grestore stroke grestore
gsave 0 0.1242 0.438 0.087  setcmykcolor gsave fill grestore stroke
grestore gsave 0 0.1242 0.438 0.087  setcmykcolor  1. .setopacityalpha
 fill  grestore gsave 0.8 SLW TeXDict begin XC@black end  1. .setopacityalpha
 0  setlinecap stroke  grestore end


@endspecial 3033 1245 a Fa(externe)d(Programme)3033
1320 y(\(Index,Bibliothek\))875 2684 y
 tx@Dict begin gsave STV newpath 0.8 SLW TeXDict begin XC@black end
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow  } def  /NCLW CLW
def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@F /N@G InitNC { tx@Dict
begin /Lineto /lineto load def false 0  setlinejoin pop end /AngleA
-90. def /AngleB 0. def /ArmA 12.80363 def /ArmB 10.0 def /ArmTypeA
0 def /ArmTypeB 0 def /AngleB -90. def NCBar  } if end  gsave 0.8 SLW
TeXDict begin XC@black end  1. .setopacityalpha  0  setlinecap stroke
 grestore  grestore end
 875 2684 a 875
2684 a
 tx@Dict begin gsave STV newpath 0.8 SLW TeXDict begin XC@black end
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow  } def  /NCLW CLW
def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@G /N@B InitNC { tx@Dict
begin /Lineto /lineto load def false 0  setlinejoin pop end /AngleA
90. def /AngleB 0. def /ArmA 10.0 def /ArmB 10.0 def /ArmTypeA 0 def
/ArmTypeB 0 def NCAngle  } if end  gsave 0.8 SLW TeXDict begin XC@black
end  1. .setopacityalpha  0  setlinecap stroke  grestore  grestore
end
 875 2684 a 1460 1643 a
 tx@Dict begin tx@NodeDict begin {10.84695 5.62248 58.46756 29.23378
2.61223 } false /N@H 16 {InitRnode } NewNode end  end
 1460 1643 a 31 w @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW TeXDict begin XC@black end  0.
true 3.8 neg 5.62248 neg 54.66756 10.84695 .5 Frame  gsave 3.0 -45.
PtoC Shadow 0 0 0 0.4  setcmykcolor gsave fill grestore stroke grestore
gsave 0 0.1656 0.584 0.116  setcmykcolor gsave fill grestore stroke
grestore gsave 0 0.1656 0.584 0.116  setcmykcolor  1. .setopacityalpha
 fill  grestore gsave 0.8 SLW TeXDict begin XC@black end  1. .setopacityalpha
 0  setlinecap stroke  grestore end
 
@endspecial Fb(DVI)p Fc(-Treiber)875 2684
y
 tx@Dict begin gsave STV newpath 0.8 SLW TeXDict begin XC@black end
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow  } def  /NCLW CLW
def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@E /N@H InitNC { NCLine
 } if end  gsave 0.8 SLW TeXDict begin XC@black end  1. .setopacityalpha
 0  setlinecap stroke  grestore  grestore end
 875 2684 a 532 1704 a
 tx@Dict begin tx@NodeDict begin {18.61697 12.98303 82.72548 41.36273
2.81697 } false /N@I 16 {InitRnode } NewNode end  end
 532 1704 a 32 w @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW TeXDict begin XC@black end  0.4
true 3.8 neg 12.98303 neg 78.92548 18.61697 .5 Frame  gsave 3.0 -45.
PtoC Shadow 0 0 0 0.4  setcmykcolor gsave fill grestore stroke grestore
gsave 0 0.0621 0.219 0.0435  setcmykcolor gsave fill grestore stroke
grestore gsave 0 0.0621 0.219 0.0435  setcmykcolor  1. .setopacityalpha
 fill  grestore gsave 0.8 SLW TeXDict begin XC@black end  1. .setopacityalpha
 0  setlinecap stroke  grestore end
 
@endspecial 613 1650 a Fc(Fonts)j(\(Type1,)613
1750 y(Type3,Bitmap\))875 2684 y
 tx@Dict begin gsave STV newpath 0.8 SLW TeXDict begin XC@black end
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow  } def  /NCLW CLW
def tx@NodeDict begin 2.56073 0.0 neg 0.0 0.0 0 0 /N@I /N@H InitNC
{ NCLine  } if end  gsave 0.8 SLW TeXDict begin XC@black end  1. .setopacityalpha
 0  setlinecap stroke  grestore  grestore end
 875 2684 a @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW TeXDict begin XC@black end  /ArrowA
{ moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4 1.4 1.5
2.   1. .setopacityalpha  Arrow  EndArrow  } def  [ 156.49008 113.81097
38.41138 113.81097   /Lineto /lineto load def false 0  setlinejoin
Line  gsave 0.8 SLW TeXDict begin XC@black end  1. .setopacityalpha
 0  setlinecap stroke  grestore end
 
@endspecial 1502 2701 a
 tx@Dict begin tx@NodeDict begin {15.8 11.8 48.22069 24.11034 2.0 }
false /N@J 16 {InitRnode } NewNode end  end
 1502 2701 a 32 w
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW TeXDict begin XC@black end  0.4
true 3.8 neg 11.8 neg 44.42068 15.8 .5 Frame  gsave 3.0 -45. PtoC Shadow
0 0 0 0.4  setcmykcolor gsave fill grestore stroke grestore gsave 0
0 0.3 0  setcmykcolor gsave fill grestore stroke grestore gsave 0 0
0.3 0  setcmykcolor  1. .setopacityalpha  fill  grestore gsave 0.8
SLW TeXDict begin XC@black end  1. .setopacityalpha  0  setlinecap
stroke  grestore end
 
@endspecial 16 w Fb(PS)p Fc(-Datei)875
2684 y
 tx@Dict begin gsave STV newpath 0.8 SLW TeXDict begin XC@black end
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow  } def  /NCLW CLW
def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@H /N@J InitNC { NCLine
 } if end  gsave 0.8 SLW TeXDict begin XC@black end  1. .setopacityalpha
 0  setlinecap stroke  grestore  grestore end
 875 2684 a @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW TeXDict begin XC@black end   /DS
2.0 2. CLW mul add 2 div def /PSTricksDotFont 0. [1.0 0.0 0.0 1.0 0.0
0.0] FontDot /Dot { moveto gsave 1.  1.  scale (b) show grestore }
bind def 99.5846 85.35823 Dot end
 
@endspecial
875 2684 a
 tx@Dict begin tx@NodeDict begin {99.5846 85.35823 } false /N@J 10
{InitPnode } NewNode end  end
 875 2684 a 951 2350 a
 tx@Dict begin tx@NodeDict begin {10.60394 5.62248 67.1975 33.59874
2.49072 } false /N@J1 16 {InitRnode } NewNode end  end
 951 2350 a 31 w @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.8 SLW TeXDict begin XC@black end  0.
true 3.8 neg 5.62248 neg 63.39749 10.60394 .5 Frame  gsave 3.0 -45.
PtoC Shadow 0 0 0 0.4  setcmykcolor gsave fill grestore stroke grestore
gsave 0 0.1656 0.584 0.116  setcmykcolor gsave fill grestore stroke
grestore gsave 0 0.1656 0.584 0.116  setcmykcolor  1. .setopacityalpha
 fill  grestore gsave 0.8 SLW TeXDict begin XC@black end  1. .setopacityalpha
 0  setlinecap stroke  grestore end
 
@endspecial Fb(ghostscript)875 2684 y
 tx@Dict begin gsave STV newpath 0.8 SLW TeXDict begin XC@black end
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow  } def  /NCLW CLW
def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@J /N@J1 InitNC { tx@Dict
begin /Lineto /lineto load def false 0  setlinejoin pop end /AngleA
180. def /AngleB 90. def /ArmA 10.0 def /ArmB 10.0 def /ArmTypeA 0
def /ArmTypeB 0 def NCAngle  } if end  gsave 0.8 SLW TeXDict begin
XC@black end  1. .setopacityalpha  0  setlinecap stroke  grestore 
grestore end
 875
2684 a 1007 2701 a
 tx@Dict begin tx@NodeDict begin {15.8 11.8 53.63864 26.81932 2.0 }
false /N@J2 16 {InitRnode } NewNode end  end
 1007 2701 a 32 w @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW TeXDict begin XC@black end  0.4
true 3.8 neg 11.8 neg 49.83864 15.8 .5 Frame  gsave 3.0 -45. PtoC Shadow
0 0 0 0.4  setcmykcolor gsave fill grestore stroke grestore gsave 0
0 0.3 0  setcmykcolor gsave fill grestore stroke grestore gsave 0 0
0.3 0  setcmykcolor  1. .setopacityalpha  fill  grestore gsave 0.8
SLW TeXDict begin XC@black end  1. .setopacityalpha  0  setlinecap
stroke  grestore end


@endspecial 16 w Fb(PDF)p Fc(-Datei)875 2684 y
 tx@Dict begin gsave STV newpath 0.8 SLW TeXDict begin XC@black end
 /ArrowA { moveto } def /ArrowB { BeginArrow 1.  1.  scale  false 0.4
1.4 1.5 2.   1. .setopacityalpha  Arrow  EndArrow  } def  /NCLW CLW
def tx@NodeDict begin 0.0 0.0 neg 0.0 0.0 0 0 /N@J1 /N@J2 InitNC {
NCLine  } if end  gsave 0.8 SLW TeXDict begin XC@black end  1. .setopacityalpha
 0  setlinecap stroke  grestore  grestore end
 875 2684
a 1952 2701 a
 tx@Dict begin tx@NodeDict begin {15.8 11.8 53.63864 26.81932 2.0 }
false /N@K 16 {InitRnode } NewNode end  end
 1952 2701 a 32 w @beginspecial @setspecial
  tx@Dict begin STP newpath 0.8 SLW TeXDict begin XC@black end  0.4
true 3.8 neg 11.8 neg 49.83864 15.8 .5 Frame  gsave 3.0 -45. PtoC Shadow
0 0 0 0.4  setcmykcolor gsave fill grestore stroke grestore gsave 0
0 0.3 0  setcmykcolor gsave fill grestore stroke grestore gsave 0 0
0.3 0  setcmykcolor  1. .setopacityalpha  fill  grestore gsave 0.8
SLW TeXDict begin XC@black end  1. .setopacityalpha  0  setlinecap
stroke  grestore end


@endspecial 16 w Fb(PDF)p Fc(-Datei)875 2684 y
 tx@Dict begin gsave STV newpath 0.8 SLW TeXDict begin XC@black end
 /ArrowA { BeginArrow 1.  1.  scale  false 0.4 1.4 1.5 2.   1. .setopacityalpha
 Arrow  EndArrow  moveto } def /ArrowB { } def  /NCLW CLW def tx@NodeDict
begin 0.0 -14.22636 neg 0.0 0.0 0 0 /N@K /N@B InitNC { tx@Dict begin
/Lineto /lineto load def false 0  setlinejoin pop end /AngleA 90. def
/AngleB -90. def /ArmA 10.0 def /ArmB 10.0 def /ArmTypeA 0 def /ArmTypeB
0 def NCAngle  } if end  gsave 0.8 SLW TeXDict begin XC@black end 
1. .setopacityalpha  0  setlinecap stroke  grestore  grestore end
 875 2684
a 2473 2152 a Fc(Der)g(Aufbau)f(eines)g(T)3163 2172 y(E)3195
2152 y(X-Systems)g(mit)2648 2252 y(pdfT)2812 2271 y(E)2845
2252 y(X)g(als)h(Compiler,)f(der)g(eine)2792 2351 y(Ausgabe)f(im)h
(PDF-)h(oder)g(im)2516 2451 y(treiberunabh\344ngigen)e(DVI-Format)3446
2551 y(erlaubt.)p 0 0 0 1 TeXcolorcmyk 0 0 0 1 TeXcolorcmyk
eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
