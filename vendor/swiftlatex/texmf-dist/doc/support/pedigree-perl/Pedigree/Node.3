.\" Automatically generated by Pod::Man 2.1801 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Pedigree::Node 3"
.TH Pedigree::Node 3 "2009-01-05" "perl v5.10.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Pedigree::Node \- the base package for nodes in pedigree charts
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use Pedigree::Node;
.PP
\&\f(CW$node\fR = new Pedigree::Node(\fI\f(CI%params\fI\fR);
.PP
\&\f(CW$node\fR\->\fICheckAllParents()\fR;
.PP
\&\f(CW$Id\fR = \f(CW$node\fR\->\fIId()\fR;
.PP
\&\f(CW$node\fR\->SetSortOrder(\-1|0|1);
.PP
\&\f(CW$result\fR = \f(CW$node\fR\->\fISortOrder()\fR;
.PP
\&\f(CW$is_numbered\fR=$node\->\fIisNumbered()\fR;
.PP
\&\f(CW$type\fR = \f(CW$node\fR\->\fIType()\fR;
.PP
\&\f(CW$Kids\fR = \f(CW$node\fR\->\fIKids()\fR;
.PP
\&\f(CW$node\fR\->\fIGetAndSortKids()\fR;
.PP
($root, \f(CW$newgen\fR) = \f(CW$node\fR\->FindRoot(\fI\f(CI$generation\fI\fR, [\fI\f(CI$sort_order\fI\fR]);
.PP
\&\f(CW$x\fR = \f(CW$node\fR\->\fIGetRelX()\fR;
.PP
\&\f(CW$y\fR = \f(CW$node\fR\->\fIGetRelY()\fR;
.PP
\&\f(CW$node\fR\->SetRelX(\fI\f(CI$x\fI\fR);
.PP
\&\f(CW$node\fR\->SetRelX(\fI\f(CI$y\fI\fR);
.PP
\&\f(CW$x\fR = \f(CW$node\fR\->\fIGetAbsX()\fR;
.PP
\&\f(CW$y\fR = \f(CW$node\fR\->\fIGetAbsY()\fR;
.PP
\&\f(CW$node\fR\->SetIndexX(\fI\f(CI$n\fI\fR);
.PP
\&\f(CW$node\fR\->SetAbsX(\fI\f(CI$x\fI\fR);
.PP
\&\f(CW$node\fR\->SetAbsY(\fI\f(CI$y\fI\fR);
.PP
\&\f(CW$n\fR = \f(CW$node\fR\->\fIGetIndexX()\fR;
.PP
\&\f(CW$area\fR = \f(CW$node\fR\->\fISetArea()\fR;
.PP
\&\f(CW$delta\fR = \f(CW$node\fR\->\fICenterKids()\fR;
.PP
\&\f(CW$node\fR\->CalcAbsCoord(\fI\f(CI$x\fI\fR, \fI\f(CI$y\fI\fR);
.PP
\&\f(CW$node\fR\->\fIAddConsanguinicMarriages()\fR;
.PP
\&\f(CW$node\fR\->AddTwins($ydist);
.PP
\&\f(CW$frame\fR = \f(CW$node\fR\->SetFrame(\fI\f(CI$xdist\fI\fR, \fI\f(CI$ydist\fI\fR);
.PP
\&\f(CW$node\fR\->DrawAll(\fI\f(CI$xdist\fI\fR, \fI\f(CI$ydist\fI\fR, \fI\f(CI$belowtextfont\fI\fR, \fI\f(CI$abovetextfont\fI\fR, 
	       \fI\f(CI@fieldsfornode\fI\fR);
.PP
\&\f(CW$node\fR\->\fIDrawConnections()\fR;
.PP
\&\f(CW$node\fR\->PrintAllLegends(\fI\f(CI$land\fI\fR, \fI\f(CI@fields\fI\fR);
.PP
\&\f(CW$node\fR\->PrintLegend(\fI\f(CI$land\fI\fR, \fI\f(CI@fields\fI\fR);
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the basic package that defines nodes for pedigrees.
\&\fIPedigree::PersonNode\fR\|(3) and \fIPedigree::MarriageNode\fR\|(3) inherit from
this package.
.Sp
.RS 4
\&\fBnew\fR(\fI\f(CI%params\fI\fR);
.Sp
Construct a new node from the given parameters.  If a node with 
the give Id exists, add new information to the node.
.Sp
\&\fBCheckAllParents\fR();
.Sp
Check whether mothers and fathers of all nodes exist
.Sp
\&\fBId\fR();
.Sp
Get Id of a node.  Note that there is no way to set an Id of a node
that was already created.
.Sp
\&\fBSetSortOrder\fR(\fI\-1|0|1\fR);
.Sp
Normally the sibs nodes are sorted by age.  However, if the nodes or
their descendants are connected by a marriage line, we must sort them
in the special way: all way to the left or all way to the right.  The
procedure \fBSetSortOrder\fR sets this flag for the node or deletes it
depending on the argument.
.Sp
\&\fBSortOrder\fR();
.Sp
Normally the sibs nodes are sorted by age.  However, if the nodes or
their descendants are connected by a marriage line, we must sort them
in the special way: all way to the left or all way to the right. The
procedure \fBSortOrder\fR checks this flag.
.Sp
\&\fBisNumbered\fR();
.Sp
Check whether the node should be numbered in pedigree
.Sp
\&\fBType\fR()
.Sp
Return node type.
.Sp
\&\fBKids\fR();
.Sp
Get the reference to the array of kids
.Sp
\&\fBGetAndSortKids\fR();
.Sp
Apply sort the array of kids for the given node
.Sp
\&\fBFindRoot\fR(\fI\f(CI$generation\fI\fR, [\fI\f(CI$sort_order\fI\fR]);
.Sp
Finds the root of the tree to which the current node belongs.  
Takes the current generation number and returns the root and its 
generation number.  Here generation numbers go \*(L"backwards\*(R":  the older
generations have higher numbers.  The found node is assigned sort order
\&\fI\f(CI$sort_order\fI\fR.
.Sp
\&\fBGetRelX\fR();
.Sp
Find the relative x coordinate of the node.  The coordinate is 
relative  to the precedessor or to the marriage node, which connects
this node to the proband
.Sp
\&\fBGetRelY\fR();
.Sp
Find the relative Y coordinate of the node.  The coordinate is 
relative  to the precedessor or to the marriage node, which connects
this node to the proband.  Note that the Y axis is down.
.Sp
\&\fBSetRelX\fR(\fI\f(CI$x\fI\fR);
.Sp
Set the relative x coordinate of the node.  The coordinate is 
relative  to the precedessor or to the marriage node, which connects
this node to the proband.
.Sp
\&\fBSetRelY\fR(\fI\f(CI$y\fI\fR);
.Sp
Set the relative y coordinate of the node.  The coordinate is 
relative  to the precedessor or to the marriage node, which connects
this node to the proband.  Note that the Y axis is down.
.Sp
\&\fBGetAbsX\fR();
.Sp
Find the absolute x coordinate of the node.
.Sp
\&\fBGetAbsY\fR();
.Sp
Find the absolute Y coordinate of the node.
.Sp
\&\fBGetIndexX\fR();
.Sp
Find the number of the node in the given generation.
.Sp
\&\fBSetAbsX\fR(\fI\f(CI$x\fI\fR);
.Sp
Set the absolute x coordinate of the node.
.Sp
\&\fBSetAbsY\fR(\fI\f(CI$y\fI\fR);
.Sp
Set the absolute y coordinate of the node.
.Sp
\&\fBSetIndexX\fR(\fI\f(CI$n\fI\fR);
.Sp
Set the number of the node in the given generation.
.Sp
\&\fBSetArea\fR();
.Sp
Calculate relative coordinates for all nodes, that are descendants of 
the given node.  We create a \fIPedigree::Area\fR\|(3) around the given node
and recursively apply the function to all descendants.  The subroutine 
returns the reference to the created area.
.Sp
\&\fBCenterKids\fR();
.Sp
Move the relative coordinates of all the kids of the given node
so the given node is centered in relation to the kids.  Returns
the shift to be applied to the \fIPedigree::Area\fR\|(3).
.Sp
\&\fBCalcAbsCoor\fR(\fI\f(CI$x\fI\fR, $<y>);
.Sp
Set the absolute coordinates of the given node, if the absolute
coordinates of the parent node are (\fI\f(CI$x\fI\fR, \fI\f(CI$y\fI\fR), and recursively
do this for all descendants of this node.   Additionally set up 
\&\fB\f(CB%node_by_gen\fB\fR.
.Sp
\&\fBAddConsanguinicMarriages\fR();
.Sp
Check the pedigree and add consanguinic marriages to it.  Note
that this procedure must be called \fBafter\fR SetAbsCoor, so 
the coordinates of all nodes are set.
.Sp
\&\fBAddTwins\fR(\fI\f(CI$ydist\fI\fR);
.Sp
Check the pedigree and add twin nodes.  Note
that this procedure must be called \fBafter\fR SetAbsCoor and
AddConsanguinicMarriages.
.Sp
\&\fBSetFrame\fR(\fI\f(CI$xidst\fI\fR, \fI\f(CI$ydist\fI\fR);
.Sp
Calculate the frame:  coordinates of the lower left and upper right
corners of the picture (in ps units).  As a side effect, add generation
numbers to each person node and calculate the X index of each node.
.Sp
\&\fBDrawConnections\fR();
.Sp
Draw the connections from the given node to its descendants
.Sp
\&\fBDrawAll\fR(\fI\f(CI$xdist\fI\fR, \fI\f(CI$ydist\fI\fR, \fI\f(CI$belowtextfont\fI\fR, 
		 \fI\f(CI$abovetextfont\fI\fR, \fI\f(CI@fieldsfornode\fI\fR);
.Sp
Draw all nodes and connections in the form suitable for
pspicture
.Sp
\&\fBPrintAllLegends\fR(\fI\f(CI$lang\fI\fR, \fI\f(CI@fields\fI\fR);
.Sp
Print legend for all the nodes.  The first parameter is the
language, the other is the fields to be included in the legend.
.Sp
\&\fBPrintLegend\fR(\fI\f(CI$lang\fI\fR, \fI\f(CI@fields\fI\fR);
.Sp
This subroutine does nothing:  a generic node has no legend.  It
is overriden by \fIPedigree::PersonNode\fR\|(3) and \fIPedigree::AbortionNode\fR\|(3).
.RE
.SH "ENVIRONMENT"
.IX Header "ENVIRONMENT"
The calling program should define \fB\f(CB$main::DEBUG\fB\fR and set it to 0
or 1.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIpedigree\fR\|(1), \fIPedigree\fR\|(3)
.SH "AUTHOR"
.IX Header "AUTHOR"
Boris Veytsman, Leila Akhmadeeva, 2006, 2007
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 80:" 4
.IX Item "Around line 80:"
You can't have =items (as at line 136) unless the first thing after the =over is an =item
