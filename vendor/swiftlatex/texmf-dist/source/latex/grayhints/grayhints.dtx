%\iffalse
% makeindex -s gglo.ist -o grayhints.gls grayhints.glo
% makeindex -s gind.ist -o grayhints.ind grayhints.idx
%<*copyright>
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% grayhints.sty package,                                %%
%% Copyright (C) 2017--2018                              %%
%%   dpstory@uakron.edu                                  %%
%%                                                       %%
%% This program can redistributed and/or modified under  %%
%% the terms of the LaTeX Project Public License         %%
%% Distributed from CTAN archives in directory           %%
%% macros/latex/base/lppl.txt; either version 1.2 of the %%
%% License, or (at your option) any later version.       %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%</copyright>
%<package>\NeedsTeXFormat{LaTeX2e}[1997/12/01]
%<package>\ProvidesPackage{grayhints}
%<package> [2018/11/01 v1.2 grayhints: Create gray hints in text fields]
%<*driver>
\documentclass{ltxdoc}
\usepackage{xcolor}
\usepackage[colorlinks,hyperindex=false]{hyperref}
\usepackage{grayhints}
%\pdfstringdefDisableCommands{\let\\\textbackslash}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\gdef\brpr#1{\texttt{\char123\relax#1\char125\relax}}
\let\darg\brpr
\let\env\texttt
\let\opt\texttt
\let\app\textsf
\let\pkg\textsf
\def\visispace{\symbol{32}}
\def\ameta#1{\ensuremath{\langle\textit{\texttt{#1}}\rangle}}
\def\meta#1{\textsl{\texttt{#1}}}
\def\SUB#1{\ensuremath{{}_{\mbox{\scriptsize\ttfamily#1}}}}
%\def\cs#1{\texttt{\bslash#1}}
\DeclareRobustCommand{\tmspace}[3]{%
  \ifmmode\mskip#1#2\else\kern#1#3\fi\relax}
\renewcommand{\,}{\tmspace+\thinmuskip{.1667em}}
\let\thinspace\,
\renewcommand{\!}{\tmspace-\thinmuskip{.1667em}}
\let\negthinspace\!
\renewcommand{\:}{\tmspace+\medmuskip{.2222em}}
\let\medspace\:
\newcommand{\negmedspace}{\tmspace-\medmuskip{.2222em}}
\renewcommand{\;}{\tmspace+\thickmuskip{.2777em}}
\let\thickspace\;
\newcommand{\negthickspace}{\tmspace-\thickmuskip{.2777em}}
\makeatletter
\renewcommand{\paragraph}
    {\@startsection{paragraph}{4}{0pt}{6pt}{-3pt}
    {\normalfont\normalsize\bfseries}}
\renewenvironment{quote}[1][]
   {\def\@rgi{#1}\ifx\@rgi\@empty
    \let\rghtm\@empty\else\def\rghtm{\rightmargin\leftmargin}\fi
    \list{}{\rghtm} %{\rightmargin\leftmargin}%
    \item\relax}
   {\endlist}
\makeatother
\InputIfFileExists{aebdocfmt.def}{\PackageInfo{grayhints}{Inputting aebdocfmt.def}}
    {\def\IndexOpt{\DescribeMacro}\def\IndexKey{\DescribeMacro}\let\setupFullwidth\relax
     \PackageInfo{grayhints}{aebdocfmt.def cannot be found}}
\begin{document}
\def\CMD#1{\textbackslash#1}
  \GetFileInfo{grayhints.sty}
  \title{\textsf{grayhints}: Create gray hints in text fields}
  \author{D. P. Story\\
    Email: \texttt{dpstory@acrotex.net}}
  \date{processed \today}
  \maketitle
  \tableofcontents
  \let\Email\texttt
  \DocInput{grayhints.dtx}
\IfFileExists{\jobname.ind}{\newpage\setupFullwidth\par\PrintIndex}{\paragraph*{Index} The index goes here.\\Execute
    \texttt{makeindex -s gind.ist -o grayhints.ind grayhints.idx}\\on the command line and recompile
    \texttt{grayhints.dtx}.}
\IfFileExists{\jobname.gls}{\PrintChanges}{\paragraph*{Change History} The list of changes goes here.\\Execute
    \texttt{makeindex -s gglo.ist -o grayhints.gls grayhints.glo}\\on the command line and recompile
    \texttt{grayhints.dtx}.}
\end{document}
%</driver>
% \fi
% \MakeShortVerb{|}
%
% \InputIfFileExists{aebdonotindex.def}{\PackageInfo{web}{Inputting aebdonotindex.def}}
%    {\PackageInfo{web}{cannot find aebdonotindex.def}}
%
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%    \changes{v1.2}{2018/11/01}{Revisions to support PDF-XChange Editor}
%    \changes{v1.1}{2018/10/04}{Modify \string\cs{FmtToGray}, \string\cs{FocusToBlack}, and
%    \string\cs{BlurToBlack} for better behavior when entry is left empty}
%    \section{Description}\previewOff
%    We often see in HTML pages or compiled executable applications, form fields (text fields, input fields)
%    that require user input. The untouched field has text within it that informs the user
%    of the nature of the data to be entered into the field. This `grayed hint' immediately
%    disappears when the user focuses the cursor on the field. Lest I be accused of being too obtuse, we
%    illustrate with an example or two.
%\begin{quote}\small
%\def\myDateFmt{yyyy/mm/dd}
%    \textField[\textColor{\matchGray}
%       \TU{Enter your first name so I can get to know you better}
%       \AA{\AAFormat{\FmtToGray{First Name}}
%       \AAKeystroke{\KeyToGray}
%       \AAOnFocus{\JS{\FocusToBlack}}
%       \AAOnBlur{\JS{\BlurToBlack}}
%       \AACalculate{\CalcToGray}
%    }]{NameFirst}{2in}{11bp}\vcgBdry[\medskipamount]
%    \textField[\textColor{\matchGray}
%       \TU{Enter your favorite date, in the indicated format}
%       \AA{\AAKeystroke{\DateKeyEx("\myDateFmt");\KeyToGray}
%       \AAFormat{\DateFmtEx("\myDateFmt");\jsR\FmtToGray{\myDateFmt}}
%       \AAOnFocus{\JS{\FocusToBlack}}
%       \AAOnBlur{\JS{\BlurToBlack}}
%       \AACalculate{\CalcToGray}
%    }]{DateField}{1in}{11bp}\cgBdry[1.5em]
%    \pushButton[\CA{Reset}
%        \TU{Press to clear to clear all fields.}
%        \A{\JS{this.resetForm();}}]{reset}{}{11bp}
%\end{quote}
%    Of course, the usual tool tips may also be provided.\medskip
%
%    \noindent It is not natural for Adobe form fields to do this, it takes a lot of support code for
%    it to work properly; the Keystroke, Format, OnFocus, OnBlur, and Calculate events are needed. The
%    verbatim listing of the first example field above is,
%
%\begin{quote}\small
%|\textField[\textColor{\matchGray}|\\
%|   \TU{Enter your first name so I can get to know you better}|\\
%|   \AA{\AAFormat{\FmtToGray{First Name}}|\\
%|   \AAKeystroke{\KeyToGray}|\\
%|   \AAOnFocus{\JS{\FocusToBlack}}|\\
%|   \AAOnBlur{\JS{\BlurToBlack}}|\\
%|   \AACalculate{\CalcToGray} %<-| required if using PDF-XChange Editor\\
%|}]{NameFirst}{2in}{11bp}|
%\end{quote}
%    Code snippets are inserted into the Keystroke, Format,
%    OnFocus, OnBlur, and Calculate events.
%
%    \paragraph*{Demo files:} Four sample files are provided: \texttt{gh-eforms.tex}, \texttt{gh-hyperref.tex},
%    \texttt{gh-fmts-eforms.tex}, and \texttt{gh-fmts-hyperref.tex}.
%
%    \section{Documentation and Code}
%
%    The \pkg{eforms} package is preferred, but you can use the form field macros of \pkg{hyperref}.
%    Any unrecognized options specified for the \pkg{grayhints} package
%    are passed on to \pkg{insdljs}. If the document
%    author does not want to use \pkg{eforms}, he/she can pass the option \opt{usehyforms}\IndexOpt{usehyforms} to use the form
%    fields of \pkg{hyperref}, in this case \pkg{insdljs} is required. For the last option, \opt{nodljs}
%    is for users of \pkg{hyperref} forms who do not want to use \pkg{insdljs}. In the latter case,
%    the option \opt{usehyforms} should not be used for that will include \pkg{insdljs}.
%    \begin{macrocode}
\DeclareOption{usehyforms}{%
    \def\FormsRequirement{\RequirePackage{insdljs}[2017/03/02]}}
\def\FormsRequirement{\RequirePackage{eforms}[2017/02/27]}
%    \end{macrocode}
%     The \IndexOpt{usealtadobe}\opt{usealtadobe} option is deprecated, the function definitions
%     are automatically loaded unless the \opt{nocalcs} or \opt{nodljs} option is taken.
%     \changes{v1.1}{2018/10/04}{Deprecated the \string\opt{usealtadobe} option, now automatically loaded}
%    \begin{macrocode}
\DeclareOption{usealtadobe}{\PackageWarningNoLine{grayhints}
  {The `usealtadobe' option is now deprecated.\MessageBreak
   The alternate functions are automatically loaded.\MessageBreak
   Please remove this grayhints package option}}
%    \end{macrocode}
%    \leavevmode\IndexOpt{nocalcs} If this option is taken, the document
%        JavaScript function \texttt{AllowCalc()} is not embedded in the document. The
%        implications are that you are not using any calculation fields.
%    \begin{macrocode}
\DeclareOption{nocalcs}{\let\nocalcs\endinput}
\let\nocalcs\relax
%    \end{macrocode}
%    \leavevmode\IndexOpt{nodljs} When this option is specified, there are no
%        requirements placed on this package; that is, neither \pkg{eforms}
%        nor \pkg{insdljs} are required.
%    \begin{macrocode}
\DeclareOption{nodljs}{\let\FormsRequirement\relax
  \let\nodljsend\endinput}
\let\nodljsend\relax
\DeclareOption*{\PassOptionsToPackage{\CurrentOption}{insdljs}}
\ProcessOptions
\FormsRequirement
%    \end{macrocode}
%    We include \texttt{eqcolor.def}, a component of \pkg{exerquiz} to help parse colors,
%    and to match JS colors with PDF colors.
%    \begin{macrocode}
\@ifundefined{jsColor}{\let\eq@YES=y\let\eq@NO=n%
  \InputIfFileExists{eqcolor.def}
  {\PackageInfo{grayhints}{Inputting eqcolor.def from exerquiz}}
  {\PackageError{grayhints}{cannot find eqcolor.def belonging
  to exerquiz}{Refresh your file name database and try again.}}
}{}
%    \end{macrocode}
%
%    \subsection{JavaScript snippets for Field JavaScript}
%    Code snippets are inserted in to the Format, Calculate,
%    OnFocus, and OnBlur events, as illustrated above.
%
%    \begin{macro}{\normalGrayColors}\hspace{-\marginparsep}\thinspace
%    \darg{\ameta{normalcolor}}\darg{\ameta{graycolor}} There are two colors
%    in play, the normal color of the text field (\ameta{normalcolor}) and
%    the color of the ``grayed'' text (\ameta{graycolor}). We set the defaults
%    to \texttt{color.black} and \texttt{color.ltGray}, respectively. The two parameters
%    are JavaScipt colors: array type \texttt{["RGB", 1, 0, 0]}, or predefined type
%    \texttt{color.blue}. The command \cs{jsColor} is used to assign colors (taken from
%    \texttt{eqcolor.def} of \pkg{exerquiz}).
%    \begin{macrocode}
\newcommand{\normalGrayColors}[2]{\def\gh@rgi{#1}\def\gh@rgii{#2}%
  \ifx\gh@rgi\@empty\else
    \jsColor\gh@normalcolor{#1}\gh@chkTr@nsparency\fi
  \ifx\gh@rgii\@empty\else\jsColor\gh@graycolor{#2}\m@tchGray\fi}
\def\gh@normalcolor{}\def\gh@graycolor{}
\AtEndOfPackage{\normalGrayColors{color.black}{color.ltGray}}
%    \end{macrocode}
%    \end{macro}
%    There are several predefined JavaScript colors the user can specify. We need to
%    convert them to PDF color too.
%    \begin{macrocode}
\definecolor{ltGray}{gray}{0.75}
\definecolor{gray}{gray}{.5}
\definecolor{dkGray}{gray}{.25}
\def\gh@pd@transparent{ltGray}\def\gh@transparent{transparent}
\def\gh@pd@black{black}\def\gh@pd@white{white}
\def\gh@pd@dkGray{dkGray}\def\gh@pd@gray{gray}\def\gh@pd@ltGray{ltGray}
\def\gh@pd@red{red}\def\gh@pd@green{green}\def\gh@pd@blue{blue}
\def\gh@pd@cyan{cyan}\def\gh@pd@magenta{magenta}
\def\gh@pd@yellow{yellow}
%    \end{macrocode}
% Convert the JS color for \cs{gh@graycolor} to a matching PDF color that can be
% used by the \cs{textColor} property of a form field. Here, we use commands defined
% in the \texttt{eqcolor.def} file from \pkg{exerquiz}. This command defines the user
% command \DescribeMacro{\matchGray}\cs{matchGray}.
%    \begin{macrocode}
\def\m@tchGray{\eq@checkRawJSColor{\gh@graycolor}%
  \ifx\eqpredefineJSCol\eq@NO
%    \end{macrocode}
%     \cs{gh@graycolor} is a JavaScript array
%    \begin{macrocode}
    \let\matchGray\@empty
    \expandafter\gh@extr@ctJSModelInfo\gh@graycolor\@nil
    \ifx\@rgi\@empty\else\edef\matchGray{\@rgi}\fi
    \ifx\@rgii\@empty\else\edef\matchGray{\matchGray\space\@rgii}\fi
    \ifx\@rgiii\@empty\else
      \edef\matchGray{\matchGray\space\@rgiii}\fi
    \ifx\@rgiv\@empty\else\edef\matchGray{\matchGray\space\@rgiv}\fi
  \else
%    \end{macrocode}
%     \cs{gh@graycolor} is a predefined color (\texttt{color.ltGray})
%    \begin{macrocode}
    \expandafter\gh@getColorFromPrefined\gh@graycolor\@nil
    \@ifundefined{gh@pd@\pd@color}{%
      \def\gh@graycolor{color.ltGray}\def\pd@color{ltGray}%
      \PackageWarning{grayhints}
        {The color.\pd@color\space is undefined,\MessageBreak
        substituting color.ltGray}}{\ifx\pd@color\gh@transparent
      \def\gh@graycolor{color.ltGray}\def\pd@color{ltGray}%
      \PackageWarning{grayhints}
        {A transparent color is not supported,\MessageBreak
        using color.ltGray instead}\fi
    }%
    \edef\matchGray{\@nameuse{gh@pd@\pd@color}}%
  \fi}
\def\gh@chkTr@nsparency{\eq@checkRawJSColor{\gh@normalcolor}%
    \ifx\eqpredefineJSCol\eq@YES
        \expandafter\gh@getColorFromPrefined\gh@normalcolor\@nil
        \@ifundefined{gh@pd@\pd@color}{\def\gh@normalcolor{color.black}%
            \PackageWarning{grayhints}
            {The color.\pd@color\space is undefined,\MessageBreak
            substituting color.black}}{}%
        \ifx\pd@color\gh@transparent\def\gh@normalcolor{color.black}%
        \PackageWarning{grayhints}
            {A transparent color is not supported,\MessageBreak
            using color.black instead}\fi
    \fi
}
%    \end{macrocode}
%    Various supporting macros to extract information.
%    \begin{macrocode}
\def\gh@extr@ctJSModelInfo[#1,#2]\@nil{%
  \gh@getspecv@lues#2,,,,\@nil}%
\def\gh@getspecv@lues#1,#2,#3,#4,#5\@nil{%
  \def\@rgi{#1}\def\@rgii{#2}\def\@rgiii{#3}\def\@rgiv{#4}}
\def\gh@getColorFromPrefined color.#1\@nil{\def\pd@color{#1}}
\def\gh@PriorFormat{event.target.savevalue=event.value;\jsR}
%    \end{macrocode}
%    \DescribeMacro{\FailStringDef} provides a helpful string when the user enters an improper string.
%    This is a language localization command.
%    \changes{v1.2}{2018/11/01}{Added \string\cs{FailStringDef}}
%    \begin{macrocode}
\newcommand\FailStringDef{continue editing}
%    \end{macrocode}
%    \DescribeMacro{\EnterCommitFailDef} Sets the code for \cs{FailStringDef}.
%    \changes{v1.2}{2018/11/01}{Added \string\cs{EnterCommitFailDef}}
%    \begin{macrocode}
\newcommand\EnterCommitFailDef{event.value=("\FailStringDef");}
%    \end{macrocode}
%    \DescribeMacro{\EnterCommitFailEvent} Sets the action when the user uses the \textsf{Enter} key to
%    commit date, and the data is not validated.
%    \changes{v1.2}{2018/11/01}{Added \string\cs{EnterCommitFailDef}}
%    \begin{macrocode}
\def\EnterCommitFailEvent#1{\def\@rgi{#1}\ifx\@rgi\@empty
  \def\gh@ECFE{\EnterCommitFailDef}\else\def\gh@ECFE{#1}\fi}
\EnterCommitFailEvent{}
%    \end{macrocode}
%    \DescribeMacro{\CommitSuccessEvent} Set what happens when entering a valid string into a formatting text field
%    \changes{v1.2}{2018/11/01}{Added \string\cs{CommitSuccessEvent}}
%    \begin{macrocode}
\def\CommitSuccessEvent#1{\def\@rgi{#1}\ifx\@rgi\@empty
\let\gh@CSE\jsR\else\def\gh@CSE{\jsR\jsT #1\jsR}\fi}
\let\gh@CSE\jsR
%    \end{macrocode}
%    \begin{macro}{\FmtToGray}\hspace{-\marginparsep}\thinspace
%    \darg{\ameta{grayhint}} This command is placed in the Format event. It places the hint
%    \ameta{grayhint} as the formatting text string when the field is empty.
%    If a built-in Adobe function is also used, use \cs{FmtToGray} after it; for example,
%    \begin{quote}\small
%       |\AAFormat{AFNumber_Format(0,1,0,0,"",true);|\\
%       |\FmtToGray{|\ameta{grayhint}|}}|
%    \end{quote}
%    \begin{macrocode}
\newcommand\FmtToGray[1]{%
  if(typeof event.target.savevalue=="undefined"){\jsR\jsT
  	event.target.savevalue="";\jsR\jsT
  	event.target.success=false;\jsR
  }\jsR
  if(typeof event.target.ghBuiltin=="undefined")%
    event.target.ghBuiltin=false;\jsR
  if(!event.target.ghBuiltin)\gh@PriorFormat
  event.target.ghBuildtin=false;\jsR\gh@FmtToGray{#1}}
\def\gh@FmtToGray#1{%
  if(typeof event.target.saverc=="undefined")%
    event.target.saverc=true;\jsR
  if(!event.target.saverc||event.value==""){\jsR\jsT
    if(event.target.savevalue!=""&&%
      !event.target.success){\jsR\jsT\gh@ECFE\jsR\jsT
%    \end{macrocode}
%     Here is the only PDF dependent code. The event sequence of close to but not exactly the
%     same as the event sequence for the Adobe PDF viewers, we must insert the following two
%     lines of code to make things work for \app{PDF-XChange Editor}.
%    \begin{macrocode}
      if(typeof app.pxceInfo!="undefined")%
        event.target.savevalue="";\jsR\jsT
    } else {\jsR\jsT\jsT
      event.target.success=false;\jsR\jsT\jsT
      event.value=("#1");\jsT\gh@CSE\jsT}\jsR
  } else {\jsR\jsT
      event.target.success=true;\gh@CSE}
}
%    \end{macrocode}
%    \end{macro}
%    \begin{macro}{\KeyToGray}
%    This command is placed in the Keystroke event. It changes
%    the color to `gray' (\cs{gh@graycolor}) if the field is empty.
%    If a built-in Adobe function is also used, use \cs{KeyToGray} after it; for example,
%    \begin{quote}\small
%       |\AAFormat{AFNumber_Keystroke(0,1,0,0,"",true);|\\
%       |\KeyToGray}|
%    \end{quote}
%    \begin{macrocode}
\newcommand\KeyToGray{%
  if(event.willCommit&&event.value!=""&&!event.rc)\jsR\jsT
  	event.target.success=false;\jsR
  event.target.saverc=event.rc;\jsR
  event.rc=true;\jsR
  if(event.willCommit&&event.value=="")%
    event.target.textColor=\gh@graycolor;\jsR
  if(event.willCommit)%
    event.target.savevalue=event.value;
}
%    \end{macrocode}
%    \end{macro}
%    \begin{macro}{\CalcToGray}
%    The \cs{CalcToGray} is a Calculate script, it is needed only in a form field that performs
%    a calculation. If a built-in Adobe function is also used, use \cs{KeyToGray} after it; for example,
%\begin{quote}\small
%  |\AACalculate{var cArray=new Array("Integer");\jsR|\\
%  |if (AllowCalc(cArray)) AFSimple_Calculate("SUM", cArray );\jsR|\\
%  |\CalcToGray}|
%\end{quote}
%    If the target population might use \app{PDF-XChange Editor}, whose features closely mimic those of
%    \app{Adobe Acrobat Reader}, the use of \cs{CalcToGray} is recommended in all fields.
%    \begin{macrocode}
\newcommand\CalcToGray{event.target.textColor=%
  (event.value=="")?\gh@graycolor:\gh@normalcolor;}
%    \end{macrocode}
%    \end{macro}
%    \begin{macro}{\FocusToBlack}
%    A command placed within the OnFocus event. When the field comes into focus, and
%    the field is empty, the color for the text is turned to black. This can be redefined
%    to another color.
%
%    \item (2018/10/04) We increase the complexity with the goal of getting a better user experience.
%    \begin{macrocode}
\newcommand\FocusToBlack{%
  if (typeof event.target.success=="undefined")%
    event.target.success=false;\jsR
  if(event.target.valueAsString==""%
    ||!event.target.success)\jsR\jsT
    event.target.textColor=\gh@normalcolor;
}
%    \end{macrocode}
%    \end{macro}
%    \begin{macro}{\BlurToBlack}
%    A command placed within the OnBlur event. It sets the text color to gray or black,
%    depending on whether the field is empty or not. My be redefined with different colors.
%
%    \item (2018/10/04) We increase the complexity with the goal of getting a better user experience.
%    \begin{macrocode}
\newcommand\BlurToBlack{%
  if (!event.target.success||event.target.valueAsString=="")\jsR\jsT
  	this.resetForm(event.target.name);\jsR
  event.target.savevalue="";\jsR
  event.target.textColor=(!event.target.success||%
  event.target.valueAsString=="")?\gh@graycolor:\gh@normalcolor;
}
%    \end{macrocode}
%    \end{macro}
%
%    \subsection{\texorpdfstring{\LaTeX}{LaTeX} commands for built-in functions}
%    We define a series of commands as a convenience to the user. The arguments of each
%    are the JavaScript argument enclosed in parentheses.\medskip\par
%    \noindent
%    \DescribeMacro{\NumKey}\cs{NumKey} for processing keystrokes for numbers, and \DescribeMacro{\NumFmt}
%    \cs{NumFmt} formats a number according to its arguments.
%    \begin{macrocode}
\def\NumKey{EFNumber_Keystroke}
\def\NumFmt(#1){try{EFNumber_Format(#1)}catch(e){}}
%    \end{macrocode}
%    \DescribeMacro{\DateKey}\cs{DateKey} and \DescribeMacro{\DateFmt}\cs{DateFmt} process the keystroke
%    and format events for a date.
%    \begin{macrocode}
\def\DateKey{EFDate_Keystroke}
\def\DateFmt(#1){%
  AFDate_Format(#1);\jsR
  event.target.ghBuiltin=true;
}
%    \end{macrocode}
%    \DescribeMacro{\DateKeyEx}\cs{DateKeyEx} and \DescribeMacro{\DateFmtEx}\cs{DateFmtEx} process the keystroke
%    and format events for a date.
%    \begin{macrocode}
\def\DateKeyEx{EFDate_KeystrokeEx}
\def\DateFmtEx(#1){%
  AFDate_FormatEx(#1);\jsR
  event.target.ghBuiltin=true;
}
%    \end{macrocode}
%    \DescribeMacro{\PercentKey}\cs{PercentKey} and \DescribeMacro{\PercentFmt}\cs{PercentFmt} process the keystroke
%    and format events for a number represented as a percentage.
%    \begin{macrocode}
\def\PercentKey{EFPercent_Keystroke}
\def\PercentFmt(#1){%
%    \end{macrocode}
%    Avoid the dreaded ``0.00\%'' when the field is blank
%    \begin{macrocode}
  if(event.value!=""||%
    (typeof event.target.savevalue!="undefined"&&%
      event.target.savevalue!=""))%
    AFPercent_Format(#1);\jsR
  event.target.ghBuiltin=true;
}
%    \end{macrocode}
%    \DescribeMacro{\TimeKey}\cs{TimeKey}, \DescribeMacro{\TimeFmt}\cs{TimeFmt}, and
%    \DescribeMacro{\TimeFmtEx}\cs{TimeFmtEx} process the keystroke
%    and format events for a time.
%    \begin{macrocode}
\def\TimeKey{EFTime_Keystroke}\def\TimeFmt{EFTime_Format}
\def\TimeFmtEx(#1){try{EFTime_FormatEx(#1)}catch(e){}}
%    \end{macrocode}
%    \DescribeMacro{\SpecialKey}\cs{SpecialKey}, \DescribeMacro{\SpecialKeyEx}\cs{SpecialKeyEx}, and
%    \DescribeMacro{\SpecialFmt}\cs{SpecialFmt} process the keystroke
%    and format events for a special format.
%    \begin{macrocode}
\def\SpecialKey{EFSpecial_Keystroke}
\def\SpecialKeyEx{EFSpecial_KeystrokeEx}
\def\SpecialFmt(#1){try{EFSpecial_Format(#1)}catch(e){}}
%    \end{macrocode}
%    \DescribeMacro{\RangeValidate}\cs{RangeValidate}, \DescribeMacro{\SimpleCalc}\cs{SimpleCalc}, and
%    \DescribeMacro{\MergeChange}\cs{\MergeChange} are specialized JS functions for setting a range
%    resstriction in the validate event, for making a simple calculation in the calculate event, and
%    a general purpose function to merging the current keystroke with event.value, valid for the keystroke
%    event.
%    \begin{macrocode}
\def\RangeValidate{EFRange_Validate}
\def\SimpleCalc{EFSimple_Calculate}
\def\MergeChange{EFMergeChange}
%    \end{macrocode}
%    \subsection{Document JavaScript to support gray hints}
%    The alternate names adobe built-in need to be used for any format function; the normal
%    built-in function names can be otherwise be used.
%    \begin{macrocode}
\nodljsend
\begin{insDLJS}{altadbfncs}{gh: Support for Adobe built-in functions}
var EFNumber_Keystroke=AFNumber_Keystroke;
function EFNumber_Format(){
  event.target.savevalue=event.value;
  event.target.ghBuiltin=true;
  AFNumber_Format.apply(null,arguments);
}
var EFDate_Keystroke=AFDate_Keystroke;
function EFDate_Format(){
  event.target.savevalue=event.value;
  event.target.ghBuiltin=true;
  AFDate_Format.apply(null,arguments);
}
var EFDate_KeystrokeEx=AFDate_KeystrokeEx;
function EFDate_FormatEx(){
  event.target.savevalue=event.value;
  event.target.ghBuiltin=true;
  AFDate_FormatEx.apply(null,arguments);
}
var EFPercent_Keystroke=AFPercent_Keystroke;
function EFPercent_Format(){
  event.target.savevalue=event.value;
  event.target.ghBuiltin=true;
  AFPercent_Format.apply(null,arguments);
}
var EFTime_Keystroke=AFTime_Keystroke;
function EFTime_Format(){
  event.target.savevalue=event.value;
  event.target.ghBuiltin=true;
  AFTime_Format.apply(null,arguments);
}
function EFTime_FormatEx(){
  event.target.savevalue=event.value;
  ghBuiltin=true;
  AFTime_FormatEx.apply(null,arguments);
}
var EFSpecial_Keystroke=AFSpecial_Keystroke;
var EFSpecial_KeystrokeEx=AFSpecial_KeystrokeEx;
function EFSpecial_Format(){
  event.target.savevalue=event.value;
  event.target.ghBuiltin=true;
  AFSpecial_Format.apply(null,arguments);
}
var EFRange_Validate=AFRange_Validate;
var EFSimple_Calculate=AFSimple_Calculate;
var EFMergeChange=AFMergeChange;
\end{insDLJS}
%    \end{macrocode}
%    \cs{nocalcs} is \cs{relax} unless the \opt{nocalcs} option is taken, in which case
%    it is \cs{let} to \cs{endinput}.
%    \begin{macrocode}
\nocalcs
\begin{insDLJS}{ghsupport}{gh: Support for the Calculate Event}
%    \end{macrocode}
%    In order to get the gray hints to appear in the terminal field of a calculation group,
%    we cannot perform the calculate when all the dependent fields are empty. \texttt{cArray}
%    is an array of all dependent fields involved in the calculation. The use of this function
%    is illustrated in \texttt{gh-eforms.tex} and \texttt{gh-hyperref.tex}.
%    \begin{macrocode}
function AllowCalc(cArray) {
  var f,g;
  for (var i=0; i<cArray.length; i++) {
    f=this.getField(cArray[i]);
    g=f.getArray();
    for (var j=0; j<g.length; j++)
      if (g[j].valueAsString!="") return true;
  }
  return false;
}
\end{insDLJS}
%    \end{macrocode}
%    \begin{macrocode}
%</package>
%    \end{macrocode}
\endinput
